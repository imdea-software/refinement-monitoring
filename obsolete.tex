%!TEX root = head.tex
\section{Removing Matched Operations}
\label{sec:obsolete}

%Since from a theoretical point of view, testing history membership is NP-complete~\cite{journals/siamcomp/GibbonsK97},

Checking history membership for large histories using the reduction to propositional SAT 
from Corollary~\ref{cor:satisfiability_pending} can still be quite inefficient. 
One way of dealing with this inefficiency is to check history membership for a fragment
of the given history provided that the smaller history being a violation to
history inclusion implies that the initial history is also a violation. 
However, deleting arbitrary operations from a history $h\in \overline{H}$
may result in a history $h'\not\in \overline{H}$. For example, removing the $\<write>(1)$ operation
from the history of the atomic register in Figure~\ref{fig:removal_even_saturation}
results in a history which is not anymore admitted by this object. To identify the
removable operations that preserve history membership we rely on the matching functions
used to characterize library kernels.

\subsection{Unique matching functions}

Recall that a history $h\in \overline{H}$ iff there exists a history $h'$ stronger than $h$
and a matching function $M : O /-> O$ such that $h',M\models \textsc{Theory}(H)$.
We assume in the following that for every history $h$, 
the matching function $M : O /-> O$ is unique and that it is defined by the 
operation labels in $h$, i.e., there exists a function $\<Matching>:\<Labels>/-> \<Labels>$
such that $M(o)=o'$ iff $\<Matching>(f(o))=f(o')$.
The matching function associated to some history $h$ is denoted by $M_h$.
We give some examples of how to construct histories of  
standard libraries with unique matching functions. 
%These constructions rely on the fact that many concurrent objects 


\begin{example}[Collections]

For usual implementations of collections 
such as stacks, queues, and sets, 
%it is 
%straightforward to instrument an implementation in order the get the matching 
%relation. 
each operation adding a value to the collection is going to 
receive as input a value which is uniquely identified by a tag. When a method removing 
an element from the collection succeeds 
%succeeds -- for instance pops an 
%element from the stack -- 
it is also going to return the unique tag associated
with that element, thus defining a unique matching function
from remove operations to add operations. The same strategy can be adapted to 
implementations of a register: the inputs to write operations are tagged 
and the read operations return tagged values.

\end{example}

\begin{example}[Locks]

The implementations of a lock object usually have two abstract states, one where the
object is unlocked, and one where it is locked. 
%We can thus instrument the 
%implementation in the following way. 
The \<lock> operations can be modified to receive as input a value which is unique
for every \<lock> operation in an execution and every successful execution
of a $\<lock>$ operation results in an object state that stores that input value.
When
an \<unlock> operation succeeds, it returns the value stored in the object state.
Therefore, the matching function maps $\<unlock>=>v$ operations to $\<lock>(v)$ operations.

\end{example}

\begin{example}[Semaphores]

Semaphore objects are usually implemented using a counter, which counts the 
number of \<acquire> operations which successfully entered the semaphore and
which are not yet released. We can instrument the implementation by keeping
a map which maps each \emph{slot} (from $1$ to the capacity $\capacity$) to a unique tag 
which was received as input by the \<acquire> operation which has that slot, if any.
When a \<release> succeeds in decrementing the counter, it returns the unique 
tag of the \<acquire> which had the slot.

\end{example}

\subsection{Closure under removing matched operations}

A \emph{match} of a history $h$ is an operation $o$ together with the maximal 
set of operations mapped by $M_h$ to $o$. 
Moreover, a match consists only of 
completed operations and at least one operation mapped to $o$. Formally, a match of a 
history $h=\tup{O,<,f}$ is a set of operations $m=o\cup M^{-1}_h(o)$ such 
that $o\in O$, $M^{-1}_h(o)\neq \emptyset$, and all the operations in $m$
are completed. The operation $o$ of a match $m=o\cup M^{-1}_h(o)$ 
is denoted by $+(m)$.

\begin{example}

Let $h$ be the history in Figure~\ref{fig:complete_removal}
such that the matching function $M_h$ maps every
$\<pop>=>i$ operation to the $\<push>(i)$ operation.
The matches of $h$ are $m_1=\{\<add>(1),\<rem>=>1\}$, $m_2=\{\<add>(2),\<rem>=>2\}$,
and $m_3=\{\<add>(3),\<rem>=>3\}$. Since every operation has a different label, 
we abuse the notation and write matches as sets of operation labels.
Then, $+(m_i)=\<add>(i)$, for each $i$.

\end{example}

A set of histories $H$ is \emph{match-removal closed} iff for every history $h\in H$
and every match $m$ of $h$, $H$ contains the history obtained from $h$ by deleting the 
operations in $m$. The history obtained from another history $h$ by deleting a set
of operations $O$ is denoted by $h\setminus O$.

The kernels of all the reference implementations described in Section~\ref{sec:logic} are 
match-removal closed. For instance, consider a sequential history $h$ in the basis of an atomic queue
and a match $m=\{\<add>(1),\<rem>=>1\}$. 
%$\sigma_1\cdot \<add>(1)\cdot\sigma_2\cdot \<rem>=>1\cdot\sigma_3$ 
%(the history is written as a sequence of operation labels) such that the matching function 
%maps the $\<rem>=>1$ operation to the $\<add>(1)$ operation. 
%These two operations form a match
%because the matching function for queue histories is injective (there is only one
%operation mapped to $\<add>(1)$).
The history obtained from $h$ by removing the match $m$
is also a valid sequential queue history because essentially, the remaining values are still removed 
in the order in which they are added. 

%\begin{theorem}
%
%The bases of the atomic stacks, queues, priority queues, sets, locks, semaphores, and of the
%exchanger are match-removal closed.
%
%\end{theorem}

The match-removal closure property extends from a kernel $H$ to the entire library $\overline{H}$.
Therefore, if by deleting matches from a history we get a history which is not admitted
by a library $\overline{H}$ then the initial history is also not admitted by $\overline{H}$.

\begin{theorem}\label{th:match_closure}

If $H$ is match-removal closed, then $\overline{H}$ is also match-removal closed.

\end{theorem}

\begin{proof}

%Let $H(B)$ be a basis of $L$, $h$ a history in $H(L)$, and $m$
%a match of $h$.
Let $h\in \overline{H}$ and $m$ a match of $h$.
By definition, %and~\ref{lemma:pending_histories}, 
there exists a history $h'\in H$ such that $h\preceq h'$. 
%Since all the operations in $m$ are completed, they are included in $h'$ with the
%same labeling. Moreover, 
By the assumptions on the matching functions, 
$m$ is also a match of $h'$.
By hypothesis, $H$ is match-removal closed which implies 
that the history $h''$ obtained from $h'$ by deleting the operations in $m$ 
is also in $H$. From the definition of $\preceq$ it follows that
the history $h\setminus m$ 
is weaker than $h''$ which implies $h\setminus m\in \overline{H}$.
\end{proof}

While the statement of Theorem~\ref{th:match_closure} implies that a history
$h\setminus m$, where $m$ is a match of $h$, belongs to $\overline{H}$ whenever $h\in \overline{H}$,
Example~\ref{ex:complete_removal} shows that the reverse is not true. 
%Consequently, 
%a monitor that eagerly removes all matching clusters from the history it tracks 
%may miss some violations.

\begin{figure}

\input figures/complete_removal

\caption{A history that is not admitted by the atomic stack. Each operation is represented
by an horizontal line segment. The line segment of an operation ending before
the line segment of another operation means that the two operations are ordered
(reading from left to right).
}
\label{fig:complete_removal}

\end{figure}

\begin{example}\label{ex:complete_removal}

Figure~\ref{fig:complete_removal} pictures a history which is not admitted by the atomic stack:
since the element $3$ was pushed after $2$, $\<pop>=>3$ should not have started after 
$\<pop>=>2$ has finished. The matching function $M_h$ maps every
$\<pop>=>i$ operation to the $\<push>(i)$ operation..
%and $h'$, the latter being an
%extension of the former. 
The history obtained by removing the 
match $\{{\tt push}(2),{\tt pop}=>2\}$ is however admitted by the atomic stack.

\end{example}

\subsection{Forgetting matched operations}

When continuously checking membership to a reference implementation 
on a history that keeps extending with new operations, 
one must ensure that forgetting matches doesn't lead to spurious violations
at later times. In the continuation of Theorem~\ref{th:match_closure},
one should also prove that a match of  
a history $h$ is a match of every extension of $h$ 
(a match of $h$ could be strictly included in a match of an extension
and therefore, not a match of the extension).
Otherwise, removing an arbitrary match before extending a history may be the same as
removing a set of operations which is not a match from the extended history
(therefore, Theorem~\ref{th:match_closure} doesn't apply).
This result holds when the matching function of all histories in the library is injective
because every match has exactly two operations. All 
the reference implementations in Section~\ref{sec:logic} fall into this case 
except for the atomic sets and registers. 

A history $h_2$ \emph{extends} a history $h_1$ if intuitively it is the history of an 
execution that extends the execution represented by $h_1$. Formally, 
$h_2=\tup{O_2,<_2,f_2}$ \emph{extends} $h_1=\tup{O_1,<_1,f_1}$, 
written $h_1 |> h_2$, iff 
\begin{itemize}

	\item $O_1\subseteq O_2$, 
	
	\item $f_1(o) \ll f_2(o)$ for each $o \in O_1$,
	
	\item $o_1 <_1 o_2$ iff $o_1 <_2 o_2$ for each $o_1,o_2\in O_1$, and
	
	\item $o_1 <_2 o_2$ for each $o_1\in O_1$ and $o_2\in O_2\setminus O_1$.

\end{itemize}

\begin{lemma}\label{lem:match_extension1}

Let $\overline{H}$ be a library s.t. $M_h$ is injective for all $h\in \overline{H}$.
For every two histories $h_1, h_2\in \overline{H}$ s.t. $h_1 |> h_2$,
if $m$ is a match of $h_1$ then $m$ is also a match of $h_2$.

\end{lemma}

Example~\ref{ex:removal_even_saturation} shows that this result doesn't 
hold when the matching function is not injective.
%a match $m$ of a history $h_1$ could be strictly included in a 
%match of an extension $h_2$ which implies that $m$ is not a match of $h_2$. 

\begin{figure}

\input figures/removal_even_saturation

\caption{Two histories $h_1$ and $h_2$ of the atomic register, where $h_2$ is an extension of $h_1$.}
\label{fig:removal_even_saturation}

\end{figure}

\begin{example}\label{ex:removal_even_saturation}

Figure~\ref{fig:removal_even_saturation} pictures two histories $h_1$ and $h_2$ of the atomic
register, the latter being an extension of the former. 
We assume that the matching function maps every
$\<read>=>i$ operation to the $\<write>(i)$ operation.
%(otherwise, the histories would not admitted by the atomic register).
The match $\{\<write>(1),\<read>=>1\}$ of $h_1$
is strictly included in the match $\{\<write>(1),\<read>=>1,\<read>=>1\}$ of $h_2$,
and therefore not a match of $h_2$.
%therefore the match of $h_1$ is not a match of $h_2$.
Removing the match of $h_1$ and extending it with the $\<read>=>1$ operation
results in a spurious violation.

\end{example}

For libraries with non-injective matching functions, we define additional conditions
to be satisfied by their kernel and by a match $m$ of a history $h$ such that
$m$ is a match of every extension of $h$. 

Let $R$ be a relation on operation
labels. We say that a history $h$ is \emph{$R$-ordered} iff for any two matches $m_1$
and $m_2$ of $h$ such that $R(+(m_1),+(m_2))$, each operation of $m_1$
is ordered before each operation of $m_2$.

Consider the atomic register and the relation $R_{reg}$ which holds for every two labels of two write operations.
Then, any history from its kernel (which by definition is sequential) is $R$-ordered
because every read operation is mapped by the matching function
to the closest preceding write operation.
Similarly, one can show that any history from the kernel of the atomic set is $R_{set}$-ordered,
where $R_{set}$ holds for every two labels $\<add>(x)$ and $\<add>(y)$ with $x=y$.

A set of histories $H$ is $R$-ordered iff every history in $H$ is $R$-ordered.
Let $\overline{H}$ be a library such that $H$ is $R$-ordered. 
A match $m$ of a history $h\in \overline{H}$ is \emph{overwritten} by 
another match $m'$ of $h$ iff 
the labels of $+(m)$ and $+(m')$ are related by $R$, 
$+(m)$ finishes before $+(m')$, and every operation 
overlapping with $+(m')$ is completed. 

\begin{example}

Given the histories $h_1$ and $h_2$ in Figure~\ref{fig:removal_even_saturation}, 
the match $\{\<write>(0),\<read>=>0,\<read>=>0\}$ is overwritten by the
match $\{\<write>(1),\<read>=>1,\<read>=>1\}$ in $h_2$ but not in $h_1$ since
a $\<read>=>0$ operation is pending in $h_1$.

\end{example}

Given a match $m$ overwritten by another match $m'$ in a history $h\in \overline{H}$, 
every new completed operation $o$ 
from an extension $h'$ of $h$ cannot be matched to $+(m)$, therefore $m$ is also a match of $h'$. 
Otherwise, since all the operations overlapping with 
$+(m')$ are completed in $h$, $o$ starts after $+(m')$ and $H$
would contain a history where the operations $+(m)$, $+(m')$, $o$ occur in this order. 
Therefore, $H$ is not $R$-ordered. 

\begin{lemma}\label{lem:match_extension2}

Let $H$ be an $R$-ordered history set.
For every two histories $h_1, h_2\in  \overline{H}$ s.t. $h_1 |> h_2$,
if $m$ is a match of $h_1$ overwritten by another match $m'$ of $h_1$, then $m$ is also a match of $h_2$.

\end{lemma}

A match $m$ of a history $h\in  \overline{H}$ is called \emph{obsolete} if (1) it is simply a
match when the matching function of every history $h\in \overline{H}$
is injective or (2) it is overwritten by another match of $h$, when $H$
is $R$-ordered.
Lemmas~\ref{lem:match_extension1} and~\ref{lem:match_extension2},  and 
Theorem~\ref{th:match_closure} imply the following.

\begin{corollary}

Let $H$ be a match-removal closed history set 
%$L$ be a library with a match-removal closed basis $B$ 
s.t.
$M_h$ is injective for all $h\in \overline{H}$ or $H$ is $R$-ordered,
for some $R$.
For every two histories $h_1, h_2\in \overline{H}$ s.t. $h_1 |> h_2$ and
$m$ an obsolete match of $h_1$, 
$h_2\setminus m$ is a history of $\overline{H}$.

\end{corollary}

TODO THE NEXT EXAMPLE SHOULD BE MOVED IN THE EXPERIMENTAL SECTION.
IT TALKS ABOUT INCREMENTALITY AND PRESERVING DEDUCED FACTS.


One way to avoid the incompleteness exhibited by Example~\ref{ex:complete_removal}
is to remove a matching cluster only if it consists of obsolete operations.
Example~\ref{ex:removal_no_saturation} shows that even this strategy is incomplete.
Intuitively, this happens because the monitor doesn't remember any constraints
on the kernel order implied by the presence of the matching cluster.

\begin{figure}

\input figures/removal_no_saturation

\caption{Removing the matching cluster $\{{\tt push}(1),{\tt pop}=>1\}$ formed of obsolete operations.}
\label{fig:removal_no_saturation}

\end{figure}

\begin{example}\label{ex:removal_no_saturation}

Figure~\ref{fig:removal_no_saturation} pictures two histories $h$ and $h'$, the latter being an
extension of the former. Even though the matching cluster $\{{\tt push}(1),{\tt pop}=>1\}$
consists only of obsolete operations, removing it from the history $h'\not\in H(L_{stacks})$ 
results in a history $h$ which is not anymore a violation, since $h\in H(L_{stacks})$.
In order to detect this violation, the monitor should remember the constraint
$\<push>(2) \poker \<pop>=>Empty$ implied by the presence of this matching cluster.

\end{example}


