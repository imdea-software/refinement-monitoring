\documentclass{sigplanconf}

\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}[section]

\DeclareMathOperator{\range}{ran}
\newcommand{\set}[1]{{\{ #1 \}}}
\newcommand{\tup}[1]{{\langle{#1}\rangle}}
\renewcommand{\implies}{\Rightarrow}
\newcommand{\db}[1]{[\![{#1}]\!]}

\begin{document}

  \special{papersize=8.5in,11in}
  \setlength{\pdfpageheight}{\paperheight}
  \setlength{\pdfpagewidth}{\paperwidth}

  \conferenceinfo{PLDI'15}{June 13--17, 2015, Portland, OR, USA}
  \CopyrightYear{2015}
  \crdata{978-1-4503-3468-6/15/06}
  \doi{nnnnnnn.nnnnnnn}

  \title{Monitoring Refinement via Symbolic Reasoning}

  \authorinfo{Michael Emmi}
    {IMDEA Software Institute}
    {michael.emmi@imdea.org}

  \authorinfo{Constantin Enea \and Jad Hamza}
    {LIAFA, Universit√© Paris Diderot}
    {\{cenea,jhamza\}@liafa.univ-paris-diderot.fr}

  \maketitle

  \begin{abstract}

    Efficient implementations of concurrent objects such as semaphores, locks,
    and atomic collections are essential to modern computing. Programming such
    objects is error prone: in minimizing the synchronization overhead between
    concurrent object invocations, one risks the conformance to reference
    implementations --- or in formal terms, one risks violating
    \emph{observational refinement}. Precisely testing this refinement even
    within a single execution is intractable, limiting existing approaches to
    executions with very few object invocations.

    We develop scalable and effective algorithms for detecting refinement
    violations. Our algorithms are founded on incremental, symbolic reasoning,
    and exploit foundational insights into the refinement-checking problem. Our
    approach is \emph{sound}, in that we detect only actual violations, and
    scales far beyond existing violation-detection algorithms. Empirically, we
    find that our approach is \emph{practically} complete, in that we detect
    the violations arising in actual executions.

  \end{abstract}
  
  \category{F.3.1}{Specifying and Verifying and Reasoning about Programs}{Mechanical verification}

  \terms
  Reliability, Verification

  \keywords
  Concurrency; Refinement; Linearizability

  \input intro
  \input refinement
  \input logic
  \input propositional
  \input obsolete
  \input empirical
  \input discussion
  \input related
  
  \section{Acknowledgements}
  
  This work is supported in part by the VECOLIB project (ANR-14-CE28-0018), the
  N-GREENS Software project (Ref. S2013/ICE-2731), and AMAROUT-II
  (EU-FP7-COFUND-291803).

  \bibliographystyle{abbrvnat}
  \bibliography{violin}

\end{document}
