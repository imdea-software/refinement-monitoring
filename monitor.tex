%!TEX root = head.tex

%\section{Monitoring History Inclusion}

\section{Reducing history membership to propositional SAT}\label{ssec:complete}

%A history formula describing the set of histories $H(B)$ 
%of a library basis $B$ is considered a specification for the entire library.
%
%Since every execution of a library $L$ can be obtained through the $~>$ rewriting 
%from an execution of a given basis $B$, 

%\begin{definition}
%
%A formula $\psi$ \emph{represents} $L$ iff there exists a basis $B$ of $L$ such that 
%for every history $h$, $h\in H(B)$ iff $h\models \psi$.
%
%\end{definition}

%Since $\psi$ is required to characterize only histories of a basis of $L$, there are
%histories of $L$ that don't satisfy $\psi$. However, for every history of $L$ there
%exists a stronger history which satisfies $\psi$.
Given a formula $\psi$ describing a basis of $L$, 
checking whether a history $h$ belongs to $H(L)$ 
can be reduced to propositional satisfiability. 
Thus, by Lemma~\ref{lemma:kernel_histories}, a history $h$ belongs to $H(L)$ iff 
it is weaker than a history $h'$ in a basis of $L$, or equivalently, weaker than a history
$h'$ satisfying $\psi$.
When $h$ is a complete history, the fact that any stronger history contains exactly the same set of 
operations~\footnote{More precisely, there exists a bijection between the set of operations in $h$ and respectively $h'$.}
enables the construction of a formula  $\mathit{Stronger}_c(h)$ characterizing all the histories
stronger than $h$. This formula conjuncted with $\psi$ describes all the histories stronger than $h$
that satisfy $\psi$. Therefore, the satisfiability of $\mathit{Stronger}_c(h)\land \psi$ is
equivalent to $h\in H(L)$. 
When the history $h$ contains pending operations, a stronger history $h'$ may contain
less operations (pending operations of $h$ can be omitted in $h'$)
and some pending operations of $h$ may be completed in $h'$.  
Therefore, the formula $\mathit{Stronger}_c(h)$ is enhanced with a domain predicate $\<ops>$
defining the set of operations in the stronger history and the return values of the pending
operations are left unconstrained. The conjunction between the obtained
formula and the formula $\psi'$ obtained from $\psi$ by guarding the quantified variables to satisfy
the domain predicate $\<ops>$ characterizes the histories stronger
than $h$ which satisfy $\psi$.

%$h\in H(L)$ is equivalent to the fact that $\mathit{Hist}(h)$ is consistent
%with the formula $\psi$ where the quantifiers are guarded by a domain predicate representing the
%set of operations in a history stronger than $h$.
%using the same
%function and predicate symbols as $\psi$. 
%using different versions $\<hb>_h$, $\<match>_h$, $\ldots$ of the predicates $\<hb>$, $\<match>$, $\ldots$, 
%and $\mathit{Weaker}$ is a formula expressing the fact that $\<hb>_h$ is included in $\<hb>$, 
%$\<match>_h$ is exactly $\<match>$, etc.

\subsection{Complete Histories}

The following two lemmas characterize the weaker than relation between histories. 
The first one states that the matching function of a history, projected over completed operations, 
is preserved by any stronger history. The second lemma states that a history $h'$ stronger than
a complete history $h$ can only differ in having more order constraints between the operations,
the operation labels and the matching function being the same in $h$ and $h'$.

\begin{lemma}

Let $h_1=\tup{O_1,<_1,f_1}$ and $h_2=\tup{O_2,<_2,f_2}$ be two histories. If $h_1\preceq_g h_2$ then
for every two completed operations $o_1, o_2\in O_1$, 
\[
\<Matching>(h_1)(o_1)=o_2\text{ iff }\<Matching>(h_2)(g^{-1}(o_1))=g^{-1}(o_2).
\]

\end{lemma}

\begin{lemma}\label{lemma:complete_history}

A complete history $h_1=\tup{O_1,<_1,f_1}$ is weaker than another history $h_2=\tup{O_2,<_2,f_2}$ 
iff there exists a bijection $g:O_2->O_1$ such that: %for every two operations $o, o'\in O_1$, 
\begin{itemize}

	\item operations related by $g$ have the same label, i.e., for each $o\in O_1$, $f_1(o)=f_2(g^{-1}(o))$,

	\item order constraints are preserved from $h_1$ to $h_2$, i.e., for each $o,o'\in O_1$, $o<_1 o'$ implies $g^{-1}(o)<_2 g^{-1}(o')$, and

	\item the matching function is the same for the two histories, i.e., for each $o,o'\in O_1$, $\<Matching>(h_1)(o)=o'$ iff $\<Matching>(h_2)(g^{-1}(o))=g^{-1}(o')$.

\end{itemize}

\end{lemma}

Given a complete history $h=\tup{O,<,f}$, let $\mathit{Stronger}_c(h)$ be a formula that characterizes
the labels, the matching function, and the order of $h$ (the operation identifiers in $O$ are used as constants):
\begin{align*}
\mathit{Stronger}_c(h)\ \triangleq\ & \forall x.\ x\in O\ \ \land \<Distinct>(O) \\
		    & \hspace{-13mm}\land\ \hspace{-2.5mm}\bigwedge_{o,o'\in O, o<o'} \hspace{-2.3mm}\<b>(o,o')\land \bigwedge_{\<Matching>(h)(o,o')} \<match>(o,o') \\
		    & \hspace{-13mm}\land\ \hspace{-7mm}\bigwedge_{\scriptsize \begin{array}{c} f(o)=m(u)=>v\end{array}} \hspace{-8mm} \<meth>(o)=m\land \<arg>(o)=u\land \<ret>(o)=v 
%		   \hspace{-7mm}\bigwedge_{\scriptsize \begin{array}{c} o,o'\in O\\f(o)=m(u)=>v\\f(o)=m'(v)=>v'\end{array}} \hspace{-7mm} \<Val>(o,o') \\
		   %\land \<PO>(<)
\end{align*}
The first sub-formula restricts the interpretation domain of every 
operation-identifier variable to $O$. The formula $x\in O$ is a syntactic sugar for 
$
\bigvee_{o\in O} x=o
$. 
The sub-formula $\<Distinct>(O)$ states that every two operation identifier constants are distinct,
i.e.,
$
\<Distinct>(O)\triangleq \bigwedge_{o_1,o_2\in O} o_1\neq o_2
$. 

%It uses indexed versions of the predicate and function symbols introduced in Section~\ref{sec:logic}
%The last sub-formula uses a relation symbol $\<hb>(o,o')$

%Also, let $\mathit{Weaker}$ be a formula expressing the weaker than relation between $h$ and another history 
%described using the standard symbols $\<hb>$, $\<meth>$, $\ldots$
%\begin{align*}
%\mathit{Weaker}\ \triangleq\ &\bigwedge_{F\in\{\<meth>,\<arg>,\<ret>\}} \forall x.\ F_h(x)=F(x) \\
%& \land\ \forall x,x'.\ \<hb>_h(x,x') => \<hb>(x,x')\\
%& \land\  \forall x,x'.\ \<match>_h(x,x') <=> \<match>(x,x')
%\end{align*}

%Also, let $\<Dom>(O)::=\forall x. x\in O$ be a


%Also, given $h$, let $F[h]$ be the HL formula $F$ where the relation symbol $<_k$ is replaced by $<$
%and the quantifiers are instantiated on the set of operations $O$, 
%i.e., every sub-formula $\exists x.\ G$ of $F$ is rewritten into
%\[
%\bigvee_{o\in O} G[x\mapsto o].
%\]

The following result states that $\mathit{Stronger}_c(h)$ characterizes precisely
all the histories stronger than $h$. It is a direct consequence of Lemma~\ref{lemma:complete_history}.

\begin{lemma}\label{lem:stronger_form_complete}

Let $h$ be a complete history. Then, for every history $h'$,
\begin{align*}
h\preceq h'\text{ iff }h'\models \mathit{Stronger}_c(h).
\end{align*}

\end{lemma}

Lemmas~\ref{lemma:kernel_histories} and~\ref{lem:stronger_form_complete} enable the following 
reduction from history membership to first-order satisfiability.

\begin{theorem}\label{th:satisfiability_pending}
Let $h$ be a complete history and $\psi$ a formula describing a basis of $L$.
Then,
\[
h\in H(L)\mbox{ iff }\mathit{Stronger}_c(h)\land \psi\mbox{ is satisfiable.}
\]
\end{theorem}
%\begin{proof}
%($=>$) This direction is a direct consequence of Lemmas~\ref{lemma:kernel_histories} and~\ref{lemma:complete_history}.
%
%%Let $h=\tup{O,<,f}$. Since $h\models \psi$, there exists a relation $\poker\subseteq O\times O$
%%such that $\tup{h,\poker}\models\psi'$, which implies that $\tup{h,\poker}$ is a model of $\varphi(h)\land \psi'$.
%
%($\Leftarrow$) The interpretation of $\<match>_h$, $\<hb>_h$, and $F_h$ with $F\in \{\<meth>,\<arg>,\<ret>\}$ 
%from a model of $\mathit{Hist}(h)\land\mathit{Weaker}\land \psi$ defines a history $h'$ such that $h\preceq h'$.
%On the other hand, the interpretation of $\<match>$, $\<hb>$, $\<meth>$, $\<arg>$, $\<ret>$ defines a history
%$h''$ such that $h'\preceq h''$ and $h''\models \psi$. Therefore, $h\preceq h''$ and $h''\models \psi$, which 
%by Lemma~\ref{lemma:kernel_histories} imply that $h\in H(L)$.
%\end{proof}

%\textcolor{red}{Say that there are no function symbols on input and output values, only = and $\leq$}

Assuming that the formula $\psi$ doesn't contain function symbols on input and output values but only
a fixed set of predicates, e.g., $=$ and $\leq$, which is the case for all the formulas in Figure~\ref{fig:examples_formulas}, 
the satisfiability of $\mathit{Stronger}_c(h)\land \psi$ 
can be reduced to propositional satisfiability.
This is based on the fact that $\mathit{Stronger}_c(h)$ fixes the domain of the operation-identifier variables to $O$
and every quantifier can be replaced by a finite conjunction/disjunction, e.g., every sub-formula $\exists x.\ A$ is replaced by 
$
\bigvee_{o\in O}\ A[x\mapsto o]
$.
Before eliminating the quantifiers, one also needs to add some universally-quantified axioms to 
express the fact that $\<b>$ is interpreted as a partial order and that $\<match>$ is interpreted as a 
partial function.
%existential quantifiers can be replaced by finite 
%disjunctions, i.e., every sub-formula $\exists x.\ A$ is replaced by 
%$
%\bigvee_{o\in O}\ A[x\mapsto o]
%$.
%The formula obtained by removing the existential quantifiers belongs to the EPR fragment
%(also known as the Bernays-Sch\"{o}nfinkel class),  whose satisfiability is known to be reducible to
%propositional satisfiability in polynomial time, provided that the quantifier count is fixed.
%The EPR fragment consists of first-order
%formulas with no occurrences of function symbols other than constants, and which  
%when written in the prenex normal form have the quantifier prefix $\exists^*\forall^*$.
%The formula $\varphi(h)\land \<Dom>(O)\land \psi'$ has no function symbols other than constants
%and by removing the existential quantifiers, it has a quantifier prefix $\forall^*$.
Therefore, one can construct a propositional formula $\mathit{Bool}_c(h,\psi)$, which
is equi-satisfiable to $\mathit{Stronger}_c(h)\land \psi$. The construction of
$\mathit{Bool}_c(h,\psi)$ can be done in polynomial time provided that the number of
quantifiers in $\psi$ is fixed, which is the case for all the formulas in Figure~\ref{fig:examples_formulas}.


\begin{corollary}\label{cor:satisfiability_complete}

Let $h$ be a complete history and $\psi$ a formula describing a basis of $L$. Then,
\[
h\in H(L)\mbox{ iff the formula}\ \mathit{Bool}_c(h,\psi)\mbox{ is satisfiable.}
\]

\end{corollary}

\subsection{Handling pending operations}\label{ssec:pending}

%The pending operations of a history $h$ may be omitted in a history stronger than $h$.
In the case of an arbitrary history $h$, the set of histories stronger than $h$ 
can be characterized by a formula obtained from $\mathit{Stronger}_c(h)$
by adding a domain predicate $\<ops>$
that is constrained to contain all the completed operations of $h$
and by omitting the constraints on the return values of pending operations.
Moreover, every pending operation of $h$ whose return value is different from $\bot$
in a model of this formula should satisfy $\<ops>$.
It can be proved that every history stronger than $h$ corresponds to a 
model of this formula, projected on the set of operations satisfying $\<ops>$.

Formally, let $\mathit{Stronger}(h)$ be the following formula:
\begin{align*}
\mathit{Stronger}(h)\ \triangleq\ & \forall x.\ x\in O\ \ \land \<Distinct>(O) \\
		    & \hspace{-10mm}\land\ \hspace{-2.5mm}\bigwedge_{o,o'\in O, o<o'} \hspace{-1.3mm}\<b>(o,o')\land \bigwedge_{\<Matching>(h)(o,o')} \<match>(o,o') \\
		    & \hspace{-10mm}\land\ \hspace{-7mm}\bigwedge_{\scriptsize \begin{array}{c} f(o)=m(u)=>v\end{array}} \hspace{-7mm} \<meth>(o)=m\land \<arg>(o)=u \\
		    & \hspace{-10mm}\land \ \hspace{-7mm}\bigwedge_{\scriptsize \begin{array}{c} f(o)=m(u)=>v\\ v\neq\bot\end{array}} \<ret>(o)=v\land \<ops>(o) \\
		    & \hspace{-10mm}\land \ \hspace{-7mm}\bigwedge_{\scriptsize \begin{array}{c} f(o)=m(u)=>\bot\end{array}} \<ret>(o)\neq\bot => \<ops>(o)
\end{align*}

The models of $\mathit{Stronger}(h)$ are histories paired with an interpretation $D$ for the domain
predicate $\<ops>$. Given such a model $\tup{h',D}$, let $h'_D$ be the history obtained from $h'$
by removing all operations $o\not\in D$.

\begin{lemma}\label{lem:stronger_form_pending}

For every history $h$,
\begin{align*}
\tup{h',D}\models \mathit{Stronger}(h)\mbox{ iff }h\preceq h'_D
\end{align*}

\end{lemma}

The predicate $\<ops>$ is also used to guard the domain of the quantifiers in 
the formula $\psi$ defining a basis of the library $L$. For simplicity,
we assume that $\psi$ is given in prenex normal form and that it has a quantifier prefix 
of the form $\forall^*\exists^*$ (all the formulas in Figure~\ref{fig:examples_formulas} can 
be written in such a form). Thus, given $\psi=\forall \vec{x}\ \exists \vec{x}'.\ F$, 
let $\psi(\<ops>)$ be the formula:
\begin{align*}
\psi(\<ops>)\triangleq\forall \vec{x}\ \exists \vec{x}'.\ \bigwedge_{x\in\vec{x}}\ \<ops>(x) => \big(\bigwedge_{x'\in\vec{x}'}\ \<ops>(x') \land F\big)
\end{align*}
As usual, universal quantifiers are guarded using implication and existential quantifiers
using conjunction.



Lemmas~\ref{lemma:kernel_histories} and~\ref{lem:stronger_form_pending}
together with the guarded quantification added to $\psi$ imply that 
history membership can be reduced to first-order satisfiability.

\begin{theorem}\label{th:satisfiability_complete}
Let $h$ be a history and $\psi=\forall \vec{x}\ \exists \vec{x}'.\ F$ a formula describing a basis of $L$.
Then,
\[
h\in H(L)\mbox{ iff }\mathit{Stronger}(h)\land \psi(\<ops>)\mbox{ is satisfiable.}
\]
\end{theorem}


%The formula $\<PO>_c$ restricts the interpretation of the universally-quantified variables to
%complete operations:
%\<PO>_c(<)


The satisfiability of the formula $\mathit{Stronger}(h)\land \psi(\<ops>)$ can be again 
reduced to propositional satisfiability since the domain of the quantifiers is fixed to the set
of operations in $h$. Let $\mathit{Bool}(h,\psi)$ be the boolean formula equi-satisfiable
to $\mathit{Stronger}(h)\land \psi(\<ops>)$.

\begin{corollary}\label{cor:satisfiability_pending}

Let $h$ be a history and $\psi$ a formula describing a basis of $L$. Then,
\[
h\in H(L)\mbox{ iff the formula}\ \mathit{Bool}(h,\psi)\mbox{ is satisfiable.}
\]
\end{corollary}



\section{Removing Matched Operations}\label{ssec:removal}

%Since from a theoretical point of view, testing history membership is NP-complete~\cite{journals/siamcomp/GibbonsK97},

Checking history membership for large histories using the reduction to propositional SAT 
from Corollary~\ref{cor:satisfiability_pending} can still be quite inefficient. 
One way of dealing with this inefficiency is to check history membership for a fragment
of the given history provided that the smaller history being a violation to
history inclusion implies that the initial history is also a violation. 
However, deleting arbitrary operations from a history $h\in H(L)$
may result in a history $h'\not\in H(L)$. For example, removing the $\<write>(1)$ operation
from the history of the atomic register pictured in Figure~\ref{fig:removal_even_saturation}
results in a history which is not anymore admitted by this object. To identify the
removable operations that preserve history membership we rely on the matching function.

A \emph{match} of a history $h$ is a completed operation $o$ together with a maximal non-empty 
set of completed operations mapped by $\<Matching>(h)$ to $o$. Formally, a match of a 
history $h=\tup{O,<,f}$ is a set of operations $m=o\cup \<Matching>^{-1}(h)(o)$ such 
that $o\in O$, $\<Matching>^{-1}(h)(o)\neq \emptyset$, and all the operations in $m$
are completed.

\begin{example}

Example of a match.

\end{example}

A set of histories $H$ is \emph{match-removal closed} iff for every history $h\in H$
and every match $m$ of $h$, $H$ contains the history obtained from $h$ by deleting the 
operations in $m$.

The bases of all the reference implementations described in Figure~\ref{fig:examples_formulas} are 
match-removal closed. For instance, consider a sequential history in the basis of an atomic queue
$\sigma_1\cdot \<add>(1)\cdot\sigma_2\cdot \<rem>=>1\cdot\sigma_3$ 
(the history is written as a sequence of operation labels) such that the matching function 
maps the $\<rem>=>1$ operation to the $\<add>(1)$ operation. 
These two operations form a match
because the matching function for queue histories is injective (there is only one
operation mapped to $\<add>(1)$).
The history $\sigma_1\cdot \sigma_2\cdot \sigma_3$ obtained by removing the match 
is also a valid sequential queue history: the order between the remaining adds and 
removes is not affected by this removal.

\fbox{Need a general explanation for this closure}

\begin{theorem}

The bases of the atomic stacks, queues, priority queues, sets, locks, semaphores, and of the
exchanger are match-removal closed.

\end{theorem}

The match-removal closure property extends from a basis to the entire library.
Therefore, if by deleting matches from a history we get a history which is not admitted
by a library $L$ then the initial history is also not admitted by $L$.

\begin{theorem}\label{th:match_closure}

If a basis of a library $L$ is match-removal closed, then $H(L)$ is also match-removal closed.

\end{theorem}

\begin{proof}

Let $H(B)$ be a basis of $L$, $h$ a history in $H(L)$, and $m$
a match of $h$.
By Lemma~\ref{lemma:kernel_histories}, %and~\ref{lemma:pending_histories}, 
there exists a history $h'\in H(B)$ such that $h\preceq h'$. 
Since all the operations in $m$ are completed, they are included in $h'$ with the
same labeling. Moreover, the matching function projected over completed
operations is preserved from $h$ to $h'$. 
By hypothesis, $H(B)$ is match-removal closed which implies 
that the history $h_1'$ obtained from $h'$ by deleting the operations in $m$ 
is also in $H(B)$. From the definition of $\preceq$ it follows that
the history $h_1$ obtained from $h$ by deleting the operations in $m$ 
is weaker than $h_1'$ which implies $h_1\in H(L)$.
\end{proof}

\section{Efficient runtime monitoring}

We describe a monitor for detecting refinement violations, which is based on the logical characterizations
introduced in Section~\ref{sec:logic}. Essentially, it records the history of the monitored execution 
and continuously checks whether it is included in the set of histories $H(L)$ of a library $L$, using
the formula $\psi$ describing $H(L)$. When the tracked history $h$ is complete, it can simply check whether
$h$ satisfies $\psi$. This satisfaction problem can be reduced to propositional satisfiability as we show in Section~\ref{ssec:complete}.
When $h$ contains pending operations, the membership test is more intricate since $\psi$ describes only complete histories.
In this case, we rely on the assumption that the operations of any execution in $\ker L$ are completed.
The membership test performed by the monitor, described in Section~\ref{ssec:pending}, 
is again based on a reduction to propositional satisfiability. However, in this case, it is sound, i.e., any reported
violation is real, but incomplete, i.e.,
there may exist refinement violations which are missed by the monitor.
Furthermore, in order to reduce space/time consumption, the monitor is allowed to forget completed 
operations. More precisely, we show in Section~\ref{ssec:removal} that forgetting matching clusters is sound  
provided that the kernel is $\<Matching>$-closed.


When continuously checking membership on a history that keeps extending 
with new operations, forgetting matches from the history would provide
an important efficiency gain. Theorem~\ref{th:match_closure} alone doesn't guarantee
that by forgetting operations, we cannot derive a violation at later times  although
the tracked history is always admitted by the library we are interested in.

doesn't prove completely the soundness of this 

One must prove prefix closure

This holds for injective matching functions

\begin{theorem}

Let $L$ be a library with a closed basis.
Let $h$ be a history of $L$ and $h'\leq_{pref} h$. If $\<Matching>(h)$ is injective for all $h$,
then for every match $m$ of $h$, $h\setminus m$ is a history of $L$.

\end{theorem}



When $\<Matching>(h)$ is not injective, e.g., for histories of a register and set, the problem is
that ...

Removing operations not in the matching relation, e.g. $\<pop>=>\<empty>$.

\newpage




Given a history $h=\tup{O,<,f}$, a set of operations $O'\subseteq O$ is called a \emph{matching cluster}
iff $O'$ consists of a single negative operation $o$ and all positive operations $o'$ with $\<Matching>(o,o')$.
A set of histories $H$ is closed under matching cluster removal iff $H$ contains all the histories
obtained by removing a matching cluster from another history in $H$. 
%We say that 
%a library $L$ is \emph{$\<Matching>$-closed} iff the set of kernel histories is closed under 
%matching cluster removal. 
Formally, given a history $h=\tup{O,<,f}$ and $O'\subseteq O$, 
\[
h\setminus O'=\tup{O\setminus O',<',f'},
\] 
where $<'=<|_{O\setminus O'}$, and $f'=f|_{O\setminus O'}$.

\begin{definition}

A set of histories $H$ is \emph{closed under matching cluster removal} 
(for short, $\<Matching>$-closed)
iff for every matching cluster $O'$ of a history $h\in H$,
the history $h\setminus O'$ also belongs to $H$.

\end{definition}

\begin{example}

Show that all objects we know satisfy this property.

\end{example}


The following result shows that removing a matching cluster from a history 
$h\in H(L)$ results in a history that also belongs to $H(L)$, 
provided that the same closure property holds for the set of kernel histories 
$H(\ker L)$.


\begin{theorem}\label{th:removing_matching}

Let $L$ be a library for which $\ker L$ is defined. If $H(\ker L)$ is $\<Matching>$-closed, 
then $H(L)$ is also $\<Matching>$-closed.

\end{theorem}

\begin{proof}

Let $h$ be a history of $H(L)$. 
By Lemmas~\ref{lemma:kernel_histories} and~\ref{lemma:pending_histories}, 
there exists a completion $h_{c}$ and a kernel history $h'\in H(\ker L)$ such that
$h\preceq_c h_{c} \preceq h'$. Also, let $O_1$ be a matching cluster of $h$.
Since all the operations in $O_1$ are completed, they are included in $h'$ with the
same labeling. By hypothesis, $H(\ker L)$ is $\<Matching>$-closed and therefore, 
$h'\setminus O_1\in H(\ker L)$. By the definition of $\preceq$, it follows that
$h_{c}\setminus O_1\preceq h'\setminus O_1$ and since the operations in $O_1$
are completed, we get that $h\setminus O_1\preceq h_{c}\setminus O_1$. Consequently,
$h\setminus O_1\in H(L)$.
\end{proof}

Theorem~\ref{th:removing_matching} provides soundness guarantees for   
a monitor that instead of checking whether the tracked history belongs to $H(L)$,
checks whether a smaller history, obtained from $h$ by removing all matching clusters,
belongs to $H(L)$. In order to define a monitor that is allowed to remove
the matching clusters from the tracked history, either the matching relation $\<Matching>$
is injective or one needs to impose supplementary
conditions on the removed clusters. When the matching function is not injective, 
a matching cluster of a history $h$ could be strictly included in a 
matching cluster of an extension of $h$. Therefore, removing it, may make the 
extension of the history without the matching cluster a spurious violation.

\begin{figure}

\input figures/removal_even_saturation

\caption{Removing the matching cluster $\{{\tt write}(1),{\tt read}=>1\}$ formed of obsolete operations.}
\label{fig:removal_even_saturation}

\end{figure}

\begin{example}\label{ex:removal_even_saturation}

Figure~\ref{fig:removal_even_saturation} pictures two histories $h$ and $h'$, the latter being an
extension of the former. Note that the matching cluster $\{\<write>(1),\<read>=>1\}$ of $h$
is strictly included in the cluster $\{\<write>(1),\<read>=>1,\<read>=>(1)\}$ of $h'$. 
Removing the cluster of $h$ and extending it with the $\<read>=>(1)$ operation
results in a spurious violation.

\end{example}

\begin{definition}

A matching cluster $O$ of a history $h$ is called \emph{obsolete} iff 

\begin{itemize}

	\item $\<Matching>$ is injective or

	\item there exists another matching cluster $O'$ of $h$ such that the positive operation in $O'$
	is obsolete and ordered after the positive operation in $O$

\end{itemize}

\end{definition}

\begin{lemma}

Let $L$ be a library such that for every two matching clusters $O_1$ and $O_2$ of a kernel history 
$h=\tup{O,<,f}$, $o_1<o_2$ for each $o_1\in O_1$ and $o_2\in O_2$. 
Also, let $h\in H(L)$ and $h'\in H(L)$ an extension of $h$. Then, there exists no matching cluster $O$ 
of $h'$, which strictly includes an obsolete matching cluster of $h$.

\end{lemma}

\begin{figure}

\input figures/complete_removal

\caption{Removing the matching cluster $\{{\tt push}(2),{\tt pop}=>2\}$ formed of complete but not obsolete operations.}
\label{fig:complete_removal}

\end{figure}

While the statement of Theorem~\ref{th:removing_matching} implies that a history
$h\setminus O$, where $O$ is a matching cluster in $h$, belongs to $H(L)$ whenever $h\in H(L)$,
Example~\ref{ex:complete_removal} shows that the reverse is not true. Consequently, 
a monitor that eagerly removes all matching clusters from the history it tracks 
may miss some violations.

\begin{example}\label{ex:complete_removal}

Figure~\ref{fig:complete_removal} pictures two histories $h$ and $h'$, the latter being an
extension of the former. The history obtained by removing the 
matching cluster $\{{\tt push}(2),{\tt pop}=>2\}$ from $h'$ belongs to $H(L_{stacks})$ while
$h'\not\in H(L_{stacks})$. Therefore, a monitor that removes all 
matching clusters when reading $h$, will miss the violation $h'$. Note that $h$ is not
a violation since $h\in H(L_{stacks})$.

\end{example}

One way to avoid the incompleteness exhibited by Example~\ref{ex:complete_removal}
is to remove a matching cluster only if it consists of obsolete operations.
Example~\ref{ex:removal_no_saturation} shows that even this strategy is incomplete.
Intuitively, this happens because the monitor doesn't remember any constraints
on the kernel order implied by the presence of the matching cluster.

\begin{figure}

\input figures/removal_no_saturation

\caption{Removing the matching cluster $\{{\tt push}(1),{\tt pop}=>1\}$ formed of obsolete operations.}
\label{fig:removal_no_saturation}

\end{figure}

\begin{example}\label{ex:removal_no_saturation}

Figure~\ref{fig:removal_no_saturation} pictures two histories $h$ and $h'$, the latter being an
extension of the former. Even though the matching cluster $\{{\tt push}(1),{\tt pop}=>1\}$
consists only of obsolete operations, removing it from the history $h'\not\in H(L_{stacks})$ 
results in a history $h$ which is not anymore a violation, since $h\in H(L_{stacks})$.
In order to detect this violation, the monitor should remember the constraint
$\<push>(2) \poker \<pop>=>Empty$ implied by the presence of this matching cluster.

\end{example}











