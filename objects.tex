%!TEX root = head.tex

\section{Matching relations}

The objects implemented in existing concurrent libraries~\footnote{For instance, {\tt java.util.concurrency} or Intel Thread Building Blocks}
behave like a collection with methods for adding and removing values from the collection, for testing the presence 
of a value or the emptiness of the collection. Even locks and semaphores can be viewed as bounded collections. For instance, a lock is 
a collection of size 1, where the methods {\tt lock} and {\tt unlock} overwrite the value in the collection. 

Every execution of a collection defines a correlation between operations that effectively add or remove the same value,
called \emph{matching relation}.
As we show in this section, this relation can be made explicit by essentially, tagging
the values added to the collection with unique identifiers. Therefore, in this work, we assume that
every execution of a library is enhanced with such a relation.

Intuitively, the first argument of a matching relation is an operation effectively deleting a value from the collection or 
testing the presence of a value in the collection, while the second argument is an operation adding 
that value to the collection. To simplify the exposition, we assume that an operation can remove only one 
occurrence of a certain value from the collection. By this assumption and since testing the presence
of a value requires finding only one occurrence of that value in the collection, we assume that
the matching relation is functional in the first argument.

\begin{definition}

Let $e$ be an execution over a set of operations $O$.
A \emph{matching relation} for $e$ is a relation $\<Matching>\subseteq O\times O$, which is functional in the first argument, % library $L$ iff for every history $h=\tup{O,<,f}$ in $H(L)$, the following holds:
i.e., for every $o\in O$ there exists an unique $o'\in O$ such that $\<Matching>(o,o')$.

\end{definition}

A matching relation $\<Matching>$ is called \emph{injective} iff it is injective in the first argument, i.e., 
for every $o_1\neq o_2\in O$, there exist two different operations $o_1'\neq o_2'\in O$ such that $\<Matching>(o_1,o_1')$ 
and $\<Matching>(o_2,o_2')$.

%\subsection{Matching Relations}\label{ssec:matching}

\newcommand{\domain}{\mathbb{D}}

%We distinguish two sets of operation labels $\<PosLab> \subseteq \<Labels>$ and $\<NegLab> \subseteq \<Labels>$, called \emph{positive}, resp., \emph{negative}, operations labels.

\begin{example}

%Positive and negative labels for different objects.



\begin{itemize}

\item{Queue}
  \begin{itemize}
  \item{Positive Labels:} $\set{\<enqueue>(x)\ |\ x \in \domain}$
  \item{Negative Labels:} $\set{\<dequeue> => x\ |\ x \in \domain}$
  \end{itemize}

\item{Stack}
  \begin{itemize}
  \item{Positive Labels:} $\set{\<push>(x)\ |\ x \in \domain}$
  \item{Negative Labels:} $\set{\<pop> => x\ |\ x \in \domain}$
  \end{itemize}

\item{Register}
  \begin{itemize}
  \item{Positive Labels:} $\set{\<write>(x)\ |\ x \in \domain}$
  \item{Negative Labels:} $\set{\<read> => x\ |\ x \in \domain}$
  \end{itemize}

\item{PriorityQueue}
  \begin{itemize}
  \item{Positive Labels:} $\set{\<add>(x)\ |\ x \in \domain}$
  \item{Negative Labels:} $\set{\<removeMax> => x\ |\ x \in \domain}$
  \end{itemize}
  
\item{Set}
  \todo{Necessary explanation for the choice we did for the set}
  \begin{itemize}
  \item{Positive Label:} $\<add>$
  \item{Negative Labels:} $\<remove>$ and $\<contains> => \top$
  \end{itemize}
  
\item{Lock}
  \begin{itemize}
  \item{Positive Label:} $\<lock>$
  \item{Negative Label:} $\<unlock>$
  \end{itemize}
  
\item{Semaphore}
  \begin{itemize}
  \item{Positive Label:} $\<acquire>$
  \item{Negative Label:} $\<release>$
  \end{itemize}

\item{Exchanger}
  \begin{itemize}
  \item{Positive Label:} $\<exchange>$
  \item{Negative Label:} $\<exchange>$
  \end{itemize}
  
\end{itemize}

\end{example}

%We assume that each concurrent library comes with a matching relation $\<Matching>$ between negative and positive labels such that for every history $h$ of that library, each negative operation label in $h$ is matched to a unique positive label in $h$. Sometimes it is also required that every two different negative operation labels are matched to different positive labels.


An operation $o$ is called \emph{negative}, resp., \emph{positive}, in a history $h=\tup{O,<,f}$ iff $f(o)\in \<NegLab>$, resp., $f(o)\in \<PosLab>$.

\begin{example}

We here give some examples of relations $\<Matching>$ and how they can be 
implemented. For usual implementations of objects which can be seen as 
containers, such as the Stack, the Queue, the Set, the Register, it is 
straightforward to instrument an implementation in order the get the matching 
relation. 

Each positive method (\<push>,\<enqueue>,\<add>,\<write>) is going to 
use a unique tag. When a negative method succeeds -- for instance pops an 
element from the stack -- it is also going to return the unique tag associated
with the element, thus giving us the relation $\<Matching>$.

\todo{What about \<unlock>'s which are called before any lock?}
For Lock objects, the implementations usually have two states, one where the
object is unlocked, and one where it is locked. We can thus instrument the 
implementation in the following way. When a \<lock> operation succeeds, the
implementation stores a unique tag corresponding to that operation. Then, when
an \<unlock> operation happens, it returns the tag of the last successful 
\<lock>, which defines \<Matching>

\todo{What about \<release>'s which don't release anything?}
Semaphore objects are usually implemented using a counter, which counts the 
number of \<acquire> operations which successfully entered the Semaphore and
which are not yet released. We can instrument the implementation by keeping
a map which maps each \emph{slot} (from $1$ to $\capacity$) to a unique tag 
corresponding to the \<acquire> operation which has the slot, if any.
When a \<release> succeeds in decrementing the counter, it returns the unique 
tag of the \<acquire> which had the slot.
\end{example}

\subsection{Kernel Closure Properties}

In this work, we consider the problem of checking refinement with respect to libraries $L$ for which $\ker L$ is defined.
The histories of executions in $\ker L$ are $H(\ker L)=\set{H(e) : e\in \ker L}$.

A \emph{prefix} of a history $h=\tup{O,<,f}$ is a history $h'=\tup{O',<',f'}$, that contains a subset of the operations in $h$,
i.e., $O'\subseteq O$, $<'=<|_{O'}$, and $f'=f|_{O'}$, and that is downward closed w.r.t. $<$, i.e., $o\in O'$ and $o'<o$ implies $o'\in O'$.

\begin{example}

Prefix of a history.

\end{example}

\begin{lemma}\label{lemma:kernel_histories_prefix}

Let $L$ be a library for which $\ker L$ is defined. The set of histories $H(\ker L)$ is prefix-closed.

\end{lemma}

Given a history $h=\tup{O,<,f}$, a set of operations $O'\subseteq O$ is called a \emph{matching cluster}
iff $O'$ consists of a single negative operation $o$ and all positive operations $o'$ with $\<Matching>(o,o')$.
A set of histories $H$ is closed under matching cluster removal iff $H$ contains all the histories
obtained by removing a matching cluster from another history in $H$. 
%We say that 
%a library $L$ is \emph{$\<Matching>$-closed} iff the set of kernel histories is closed under 
%matching cluster removal. 
Formally, given a history $h=\tup{O,<,f}$ and $O'\subseteq O$, 
\[
h\setminus O'=\tup{O\setminus O',<',f'},
\] 
where $<'=<|_{O\setminus O'}$, and $f'=f|_{O\setminus O'}$.

\begin{definition}

A set of histories $H$ is \emph{closed under matching cluster removal} 
(for short, $\<Matching>$-closed)
iff for every matching cluster $O'$ of a history $h\in H$,
the history $h\setminus O'$ also belongs to $H$.

\end{definition}

\begin{example}

Show that all objects we know satisfy this property.

\end{example}
