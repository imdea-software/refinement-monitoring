%!TEX root = head.tex

\section{Matching relations}

The objects implemented in existing concurrent libraries~\footnote{For instance, {\tt java.util.concurrency} or Intel Thread Building Blocks}
behave like a collection with methods for adding and removing values from the collection, for testing the presence 
of a value or the emptiness of the collection. Even locks and semaphores can be viewed as bounded collections. For instance, a lock is 
a collection of size 1, where the methods {\tt lock} and {\tt unlock} overwrite the value in the collection. 

Every execution of a collection defines a correlation between operations that effectively add or remove the same value,
called \emph{matching relation}.
As we show in this section, this relation can be made explicit by essentially, tagging
the values added to the collection with unique identifiers. Therefore, in this work, we assume that
every execution of a library is enhanced with such a relation.

Intuitively, the first argument of a matching relation is an operation effectively deleting a value from the collection or 
testing the presence of a value in the collection, while the second argument is an operation adding 
that value to the collection. To simplify the exposition, we assume that an operation can remove only one 
occurrence of a certain value from the collection. By this assumption and since testing the presence
of a value requires finding only one occurrence of that value in the collection, we assume that
the matching relation is functional in the first argument.

\begin{definition}

Let $e$ be an execution over a set of operations $O$.
A \emph{matching relation} for $e$ is a relation $\<Matching>\subseteq O\times O$, which is functional in the first argument, % library $L$ iff for every history $h=\tup{O,<,f}$ in $H(L)$, the following holds:
i.e., for every $o,o_1,o_2\in O$ if $\<Matching>(o,o_1)$ and $\<Matching>(o,o_2)$, then $o_1=o_2$.

\end{definition}

A matching relation $\<Matching>$ is called \emph{injective} iff it is injective in the first argument, i.e., 
 for every $o,o_1,o_2\in O$ if $\<Matching>(o_1,o)$ and $\<Matching>(o_2,o)$, then $o_1=o_2$.	
%for every $o_1\neq o_2\in O$, there exist two different operations $o_1'\neq o_2'\in O$ such that $\<Matching>(o_1,o_1')$ 
%and $\<Matching>(o_2,o_2')$.

An operation occurring as the first, resp., second, argument of a matching relation is called negative, resp., positive.

%\subsection{Matching Relations}\label{ssec:matching}

\newcommand{\domain}{\mathbb{D}}

%We distinguish two sets of operation labels $\<PosLab> \subseteq \<Labels>$ and $\<NegLab> \subseteq \<Labels>$, called \emph{positive}, resp., \emph{negative}, operations labels.

\begin{example}

Positive/negative labels for different objects.\\

%\begin{table}
%\begin{center}
\begin{tabular}{l | l | l}
Object &  Positive & Negative \\\hline
Queue & \<enqueue> & \<dequeue> \\
Stack & \<push> & \<pop> \\
Register & \<write> & \<read> \\
PriorityQueue & \<add> & \<removeMax> \\
Set & \<add> & \<remove> \\
Lock & \<lock> & \<unlock> \\
Semaphore & \<acquire> & \<release> \\
Exchanger & \<exchange> & \<exchange>\\
\end{tabular}

\end{example}
%\end{center}
%\caption{Positive and negative labels for different objects}
%\end{table}

%\begin{itemize}
%
%\item{Queue}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<enqueue>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<dequeue> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{Stack}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<push>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<pop> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{Register}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<write>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<read> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{PriorityQueue}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<add>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<removeMax> => x\ |\ x \in \domain}$
%  \end{itemize}
%  
%\item{Set}
%  \todo{Necessary explanation for the choice we did for the set}
%  \begin{itemize}
%  \item{Positive Label:} $\<add>$
%  \item{Negative Labels:} $\<remove>$ and $\<contains> => \top$
%  \end{itemize}
%  
%\item{Lock}
%  \begin{itemize}
%  \item{Positive Label:} $\<lock>$
%  \item{Negative Label:} $\<unlock>$
%  \end{itemize}
%  
%\item{Semaphore}
%  \begin{itemize}
%  \item{Positive Label:} $\<acquire>$
%  \item{Negative Label:} $\<release>$
%  \end{itemize}
%
%\item{Exchanger}
%  \begin{itemize}
%  \item{Positive Label:} $\<exchange>$
%  \item{Negative Label:} $\<exchange>$
%  \end{itemize}
%  
%\end{itemize}

%\end{example}

%We assume that each concurrent library comes with a matching relation $\<Matching>$ between negative and positive labels such that for every history $h$ of that library, each negative operation label in $h$ is matched to a unique positive label in $h$. Sometimes it is also required that every two different negative operation labels are matched to different positive labels.


%An operation $o$ is called \emph{negative}, resp., \emph{positive}, in a history $h=\tup{O,<,f}$ iff $f(o)\in \<NegLab>$, resp., $f(o)\in \<PosLab>$.

\begin{definition}

A \emph{tagged execution} is a pair $\tup{e,\<Matching>}$, where $e$ is an execution and $\<Matching>$
is a matching relation for $e$. The \emph{history} of a tagged execution $\tup{e,\<Matching>}$
is the tuple $\tup{O,<,f,\<Matching>}$, where $\tup{O,<,f}$ is the history of $e$.

\end{definition}

\begin{example}

We here give some examples of how to obtain tagged executions from 
standard libraries. For usual implementations of objects which can be seen as 
containers, such as the Stack, the Queue, the Set, the Register, it is 
straightforward to instrument an implementation in order the get the matching 
relation. 

Each positive method (\<push>,\<enqueue>,\<add>,\<write>) is going to 
use a unique tag. When a negative method succeeds -- for instance pops an 
element from the stack -- it is also going to return the unique tag associated
with the element, thus giving us the relation $\<Matching>$.

For Lock objects, the implementations usually have two states, one where the
object is unlocked, and one where it is locked. We can thus instrument the 
implementation in the following way. When a \<lock> operation succeeds, the
implementation stores a unique tag corresponding to that operation. Then, when
an \<unlock> operation succeeds, it returns the tag of the last successful 
\<lock>, which defines \<Matching>

Semaphore objects are usually implemented using a counter, which counts the 
number of \<acquire> operations which successfully entered the Semaphore and
which are not yet released. We can instrument the implementation by keeping
a map which maps each \emph{slot} (from $1$ to $\capacity$) to a unique tag 
corresponding to the \<acquire> operation which has the slot, if any.
When a \<release> succeeds in decrementing the counter, it returns the unique 
tag of the \<acquire> which had the slot.

\end{example}



In the following we assume that a library $L$ is a set of tagged executions 
(still satisfying the closure properties in Defintion~\ref{def:library}) and also, that
the matching relation for an execution is unique, i.e., for every two tagged executions 
$\tup{e,\<Matching>_1}$ and $\tup{e,\<Matching>_2}$ of $L$, $\<Matching>_1$ is the
same as $\<Matching>_2$.


