%!TEX root = head.tex

\section{Matching functions}

From an abstract point of view, all the objects implemented in existing 
concurrent libraries~\footnote{For instance, {\tt java.util.concurrency} or Intel Thread Building Blocks}
are \emph{collections} with methods for adding and removing values from the collection, for testing the presence 
of a value or the emptiness of the collection. Besides obvious examples like stacks and queues, 
synchronization objects like locks and semaphores are also collections, in this case of bounded size. 
For instance, a semaphore is a collection, where the methods $\<acquire>$ and $\<release>$
remove and respectively add elements to the collection. In this case, the collection cannot 
increase over an a-priori fixed size.

Every low-level execution of a collection defines a correlation between operations that effectively add 
and respectively remove the same value, or the same version of a value if we consider collections
that store a multiset of values. For instance, an execution of a stack implementation relates
every $\<pop>=>v$ operation to the $\<push>(v)$ operation that added the version of $v$ returned 
by $\<pop>$ (the value $v$ could be added several times using different $\<push>$ operations).
This correlation, called \emph{matching function}, 
is determined by the input values and the interleaving between the internal actions of 
the different operations in the low-level execution. Therefore, when observing only the sequence of call
and return actions, different matching functions might be possible. Nevertheless, one can 
slightly modify the input, e.g., by tagging the values added to the collection with unique identifiers, 
and/or add specific return values to the operations, e.g., a remove operation returns
the tag of the removed value, such that the matching
function is uniquely determined by the sequence of call and return actions.

Throughout this work we assume that every execution $e$ (of any library) is mapped to 
a unique matching function $\<Matching>(e):O/-> O$, where $O$ is the set of operations in $e$
($/->$ denotes a partial function).
Typically, the domain of $\<Matching>(e)$ consists of operations deleting a value from the collection or 
testing the presence of a value while the image of $\<Matching>(e)$ consists of operations  
adding a value to the collection~\footnote{For simplicity, we assume that an operation can remove only one 
occurrence of a certain value from the collection.}.
The operations in the domain, resp., the image, of $\<Matching>(e)$ are called negative, resp., positive, operations.

%\subsection{Matching Relations}\label{ssec:matching}

\newcommand{\domain}{\mathbb{D}}

%We distinguish two sets of operation labels $\<PosLab> \subseteq \<Labels>$ and $\<NegLab> \subseteq \<Labels>$, called \emph{positive}, resp., \emph{negative}, operations labels.

%Without Example environment. Describe for each object the mapping and how it is implemented at the same time

%\begin{example}
%
%Positive/negative labels for different objects.\\
%
%%\begin{table}
%%\begin{center}
%\begin{tabular}{l | l | l}
%Object &  Positive & Negative \\\hline
%Queue & \<enqueue> & \<dequeue> \\
%Stack & \<push> & \<pop> \\
%Register & \<write> & \<read> \\
%PriorityQueue & \<add> & \<removeMax> \\
%Set & \<add> & \<remove> \\
%Lock & \<lock> & \<unlock> \\
%Semaphore & \<acquire> & \<release> \\
%Exchanger & \<exchange> & \<exchange>\\
%\end{tabular}

%\end{example}
%\end{center}
%\caption{Positive and negative labels for different objects}
%\end{table}

%\begin{itemize}
%
%\item{Queue}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<enqueue>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<dequeue> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{Stack}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<push>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<pop> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{Register}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<write>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<read> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{PriorityQueue}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<add>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<removeMax> => x\ |\ x \in \domain}$
%  \end{itemize}
%  
%\item{Set}
%  \todo{Necessary explanation for the choice we did for the set}
%  \begin{itemize}
%  \item{Positive Label:} $\<add>$
%  \item{Negative Labels:} $\<remove>$ and $\<contains> => \top$
%  \end{itemize}
%  
%\item{Lock}
%  \begin{itemize}
%  \item{Positive Label:} $\<lock>$
%  \item{Negative Label:} $\<unlock>$
%  \end{itemize}
%  
%\item{Semaphore}
%  \begin{itemize}
%  \item{Positive Label:} $\<acquire>$
%  \item{Negative Label:} $\<release>$
%  \end{itemize}
%
%\item{Exchanger}
%  \begin{itemize}
%  \item{Positive Label:} $\<exchange>$
%  \item{Negative Label:} $\<exchange>$
%  \end{itemize}
%  
%\end{itemize}

%\end{example}

%We assume that each concurrent library comes with a matching relation $\<Matching>$ between negative and positive labels such that for every history $h$ of that library, each negative operation label in $h$ is matched to a unique positive label in $h$. Sometimes it is also required that every two different negative operation labels are matched to different positive labels.


%An operation $o$ is called \emph{negative}, resp., \emph{positive}, in a history $h=\tup{O,<,f}$ iff $f(o)\in \<NegLab>$, resp., $f(o)\in \<PosLab>$.

%\begin{definition}
%
%A \emph{tagged execution} is a pair $\tup{e,\<Matching>}$, where $e$ is an execution and $\<Matching>$
%is a matching relation for $e$. The \emph{history} of a tagged execution $\tup{e,\<Matching>}$
%is the tuple $\tup{O,<,f,\<Matching>}$, where $\tup{O,<,f}$ is the history of $e$.
%
%\end{definition}

\begin{example}[Collections]

We here give some examples of how to construct executions of  
standard libraries with unique matching functions. 
For usual implementations of collections 
such as stacks, queues, and sets, 
%it is 
%straightforward to instrument an implementation in order the get the matching 
%relation. 
each operation adding a value to the collection is going to 
receive as input a value which is uniquely identified by a tag. When a method removing 
an element from the collection succeeds 
%succeeds -- for instance pops an 
%element from the stack -- 
it is also going to return the unique tag associated
with that element, thus defining a unique matching function
from remove operations to add operations. The same strategy can be adapted to 
implementations of a register: the inputs to write operations are tagged 
and the read operations return tagged values.

\end{example}

\begin{example}[Locks]

The implementations of a lock object usually have two abstract states, one where the
object is unlocked, and one where it is locked. 
%We can thus instrument the 
%implementation in the following way. 
The \<lock> operations can be modified to receive as input a value which is unique
for every \<lock> operation in an execution and every successful execution
of a $\<lock>$ operation results in an object state that stores that input value.
When
an \<unlock> operation succeeds, it returns the value stored in the object state.
Therefore, the matching function maps $\<unlock>=>v$ operations to $\<lock>(v)$ operations.

\end{example}

\begin{example}[Semaphores]

Semaphore objects are usually implemented using a counter, which counts the 
number of \<acquire> operations which successfully entered the semaphore and
which are not yet released. We can instrument the implementation by keeping
a map which maps each \emph{slot} (from $1$ to the capacity $\capacity$) to a unique tag 
which was received as input by the \<acquire> operation which has that slot, if any.
When a \<release> succeeds in decrementing the counter, it returns the unique 
tag of the \<acquire> which had the slot.

\end{example}

We assume that the matching functions satisfy the following sanity conditions:
\begin{itemize}

\item for every execution $e$, if $\<Matching>(e)(o)=o'$, then the call action of $o'$
occurs before the return action of $o$ in $e$,

\item $\<Matching>(e)=\<Matching>(e')$ for each execution $e'$ obtained by 
isomorphic renaming of operation identifiers from $e$, 

\item for every executions $e$ and $e'$, if $e~>e'$  then $\<Matching>(e)=\<Matching>(e')$.

\item for every prefix $e$ of an execution $e'$, the domain of $\<Matching>(e)$ is
included in the domain of $\<Matching>(e')$ and $\<Matching>(e)(o)=\<Matching>(e')(o)$
for each $o$ in the domain of $\<Matching>(e)$,

\end{itemize}

By Lemma~\ref{lemma:history_derivations}, every history $h$ corresponds to a 
unique matching function denoted by $\<Matching>(h)$.

%In the following we assume that a library $L$ is a set of tagged executions 
%(still satisfying the closure properties in Definition~\ref{def:library}) and also, that
%the matching relation for an execution is unique, i.e., for every two tagged executions 
%$\tup{e,\<Matching>_1}$ and $\tup{e,\<Matching>_2}$ of $L$, $\<Matching>_1=\<Matching>_2$.
%Moreover, we assume that the history $H(e)$ of a tagged execution $\tup{e,\<Matching>}$
%is the tuple $\tup{O,<,f,\<Matching>}$, where $\tup{O,<,f}$ is defined as for untagged executions.
%
%\begin{definition}\label{def:weaker_than}
%
%  Let $h_1 = \tup{O_1,<_1,f_1,\<Matching>_1}$ and $h_2 = \tup{O_2,<_2,f_2,\<Matching>_2}$. We say $h_1$ is
%  \emph{weaker than} $h_2$, written $h_1 \preceq h_2$, when there exists an
%  injection $g: O_2 -> O_1$ such that
%  \begin{itemize}
%
%    \item $o \in \<range>(g)$ when $f_1(o) = m(u) => v$ and $v \neq \bot$,
%
%    \item $g(o_1) <_1 g(o_2)$ implies $o_1 <_2 o_2$ for each $o_1, o_2 \in O_2$,
%
%    %therefore, R_2 can say more only about pending ops 
%    \item for every two completed operations $o_1, o_2\in O_1$, $\<Matching>_1(o_1,o_2)$ iff $\<Matching>_2(g^{-1}(o_1),g^{-1}(o_2))$,
%
%    \item $f_1(g(o)) \ll f_2(o)$ for each $o \in O_2$.
%
%  \end{itemize}
%  where $(m_1(u_1) => v_1) \ll (m_2(u_2) => v_2)$ if{f} $m_1 = m_2$, $u_1 =
%  u_2$, and $v_1 \in \set{ v_2, \bot }$. We say $h_1$ and $h_2$ are
%  \emph{equivalent} when $h_1 \preceq h_2$ and $h_2 \preceq h_1$.
%
%\end{definition}


