%!TEX root = head.tex

\section{Matching functions}

From an abstract point of view, all the objects implemented in existing 
concurrent libraries~\footnote{For instance, {\tt java.util.concurrency} or Intel Thread Building Blocks}
are \emph{collections} with methods for adding and removing values from the collection, for testing the presence 
of a value or the emptiness of the collection. Besides obvious examples like stacks and queues, 
synchronization objects like locks and semaphores are also collections, in this case of bounded size. 
For instance, a lock is a collection of size 1, where the methods $\<lock>$ and $\<unlock>$ overwrite 
the only value stored in the collection. 

Every low-level execution of a collection defines a correlation between operations that effectively add 
and respectively remove the same value, or the same version of a value if we consider collections
that store a multiset of values. For instance, an execution of a stack implementation relates
every $\<pop>=>v$ operation to the $\<push>(v)$ operation that added the version of $v$ returned 
by $\<pop>$ (the value $v$ could be added several times using different $\<push>$ operations).
This correlation, called \emph{matching function}, 
is determined by the input values and the interleaving between the internal actions of 
the different operations in the low-level execution. Therefore, when observing only the sequence of call
and return actions, different matching functions might be possible. Nevertheless, one can 
slightly modify the input, e.g., by tagging the values added to the collection with unique identifiers, 
and/or add specific return values to the operations, e.g., a remove operation returns
the tag of the removed value, such that the matching
function is uniquely determined by the sequence of call and return actions.

Throughout this work we assume that every execution $e$ (of any library) is mapped to 
a unique matching function $\<Matching>(e):O/-> O$, where $O$ is the set of operations in $e$
($/->$ denotes a partial function).
Typically, the domain of $\<Matching>(e)$ consists of operations deleting a value from the collection or 
testing the presence of a value while the image of $\<Matching>(e)$ consists of operations  
adding a value to the collection~\footnote{For simplicity, we assume that an operation can remove only one 
occurrence of a certain value from the collection.}.
The operations in the domain, resp., the image, of $\<Matching>(e)$ are called negative, resp., positive, operations.

%\subsection{Matching Relations}\label{ssec:matching}

\newcommand{\domain}{\mathbb{D}}

%We distinguish two sets of operation labels $\<PosLab> \subseteq \<Labels>$ and $\<NegLab> \subseteq \<Labels>$, called \emph{positive}, resp., \emph{negative}, operations labels.

\begin{example}

Positive/negative labels for different objects.\\

%\begin{table}
%\begin{center}
\begin{tabular}{l | l | l}
Object &  Positive & Negative \\\hline
Queue & \<enqueue> & \<dequeue> \\
Stack & \<push> & \<pop> \\
Register & \<write> & \<read> \\
PriorityQueue & \<add> & \<removeMax> \\
Set & \<add> & \<remove> \\
Lock & \<lock> & \<unlock> \\
Semaphore & \<acquire> & \<release> \\
Exchanger & \<exchange> & \<exchange>\\
\end{tabular}

\end{example}
%\end{center}
%\caption{Positive and negative labels for different objects}
%\end{table}

%\begin{itemize}
%
%\item{Queue}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<enqueue>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<dequeue> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{Stack}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<push>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<pop> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{Register}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<write>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<read> => x\ |\ x \in \domain}$
%  \end{itemize}
%
%\item{PriorityQueue}
%  \begin{itemize}
%  \item{Positive Labels:} $\set{\<add>(x)\ |\ x \in \domain}$
%  \item{Negative Labels:} $\set{\<removeMax> => x\ |\ x \in \domain}$
%  \end{itemize}
%  
%\item{Set}
%  \todo{Necessary explanation for the choice we did for the set}
%  \begin{itemize}
%  \item{Positive Label:} $\<add>$
%  \item{Negative Labels:} $\<remove>$ and $\<contains> => \top$
%  \end{itemize}
%  
%\item{Lock}
%  \begin{itemize}
%  \item{Positive Label:} $\<lock>$
%  \item{Negative Label:} $\<unlock>$
%  \end{itemize}
%  
%\item{Semaphore}
%  \begin{itemize}
%  \item{Positive Label:} $\<acquire>$
%  \item{Negative Label:} $\<release>$
%  \end{itemize}
%
%\item{Exchanger}
%  \begin{itemize}
%  \item{Positive Label:} $\<exchange>$
%  \item{Negative Label:} $\<exchange>$
%  \end{itemize}
%  
%\end{itemize}

%\end{example}

%We assume that each concurrent library comes with a matching relation $\<Matching>$ between negative and positive labels such that for every history $h$ of that library, each negative operation label in $h$ is matched to a unique positive label in $h$. Sometimes it is also required that every two different negative operation labels are matched to different positive labels.


%An operation $o$ is called \emph{negative}, resp., \emph{positive}, in a history $h=\tup{O,<,f}$ iff $f(o)\in \<NegLab>$, resp., $f(o)\in \<PosLab>$.

%\begin{definition}
%
%A \emph{tagged execution} is a pair $\tup{e,\<Matching>}$, where $e$ is an execution and $\<Matching>$
%is a matching relation for $e$. The \emph{history} of a tagged execution $\tup{e,\<Matching>}$
%is the tuple $\tup{O,<,f,\<Matching>}$, where $\tup{O,<,f}$ is the history of $e$.
%
%\end{definition}

\begin{example}

We here give some examples of how to obtain tagged executions from 
standard libraries. For usual implementations of objects which can be seen as 
containers, such as the Stack, the Queue, the Set, the Register, it is 
straightforward to instrument an implementation in order the get the matching 
relation. 

Each positive method (\<push>,\<enqueue>,\<add>,\<write>) is going to 
use a unique tag. When a negative method succeeds -- for instance pops an 
element from the stack -- it is also going to return the unique tag associated
with the element, thus giving us the relation $\<Matching>$.

For Lock objects, the implementations usually have two states, one where the
object is unlocked, and one where it is locked. We can thus instrument the 
implementation in the following way. When a \<lock> operation succeeds, the
implementation stores a unique tag corresponding to that operation. Then, when
an \<unlock> operation succeeds, it returns the tag of the last successful 
\<lock>, which defines \<Matching>

Semaphore objects are usually implemented using a counter, which counts the 
number of \<acquire> operations which successfully entered the Semaphore and
which are not yet released. We can instrument the implementation by keeping
a map which maps each \emph{slot} (from $1$ to $\capacity$) to a unique tag 
corresponding to the \<acquire> operation which has the slot, if any.
When a \<release> succeeds in decrementing the counter, it returns the unique 
tag of the \<acquire> which had the slot.

\end{example}

We assume that the matching functions satisfy the following sanity conditions:
\begin{itemize}

\item for every execution $e$, if $\<Matching>(e)(o)=o'$, then the call action of $o'$
occurs before the return action of $o$ in $e$,

\item for every prefix $e$ of an execution $e'$, the domain of $\<Matching>(e)$ is
included in the domain of $\<Matching>(e')$ and $\<Matching>(e)(o)=\<Matching>(e')(o)$
for each $o$ in the domain of $\<Matching>(e)$,

\item for every two executions $e$ and $e'$, if $e~>e'$ then $\<Matching>(e)=\<Matching>(e')$.

\end{itemize}

\begin{lemma}\label{lemma:history_derivations}

Let $e$, $e'$ be two executions such that $H(e)=H(e')$. Then, $e~>e'$.

\end{lemma}

By Lemma~\ref{lemma:history_derivations}, every history $h$ corresponds to a 
unique matching function denoted by $\<Matching>(h)$.

%In the following we assume that a library $L$ is a set of tagged executions 
%(still satisfying the closure properties in Definition~\ref{def:library}) and also, that
%the matching relation for an execution is unique, i.e., for every two tagged executions 
%$\tup{e,\<Matching>_1}$ and $\tup{e,\<Matching>_2}$ of $L$, $\<Matching>_1=\<Matching>_2$.
%Moreover, we assume that the history $H(e)$ of a tagged execution $\tup{e,\<Matching>}$
%is the tuple $\tup{O,<,f,\<Matching>}$, where $\tup{O,<,f}$ is defined as for untagged executions.
%
%\begin{definition}\label{def:weaker_than}
%
%  Let $h_1 = \tup{O_1,<_1,f_1,\<Matching>_1}$ and $h_2 = \tup{O_2,<_2,f_2,\<Matching>_2}$. We say $h_1$ is
%  \emph{weaker than} $h_2$, written $h_1 \preceq h_2$, when there exists an
%  injection $g: O_2 -> O_1$ such that
%  \begin{itemize}
%
%    \item $o \in \<range>(g)$ when $f_1(o) = m(u) => v$ and $v \neq \bot$,
%
%    \item $g(o_1) <_1 g(o_2)$ implies $o_1 <_2 o_2$ for each $o_1, o_2 \in O_2$,
%
%    %therefore, R_2 can say more only about pending ops 
%    \item for every two completed operations $o_1, o_2\in O_1$, $\<Matching>_1(o_1,o_2)$ iff $\<Matching>_2(g^{-1}(o_1),g^{-1}(o_2))$,
%
%    \item $f_1(g(o)) \ll f_2(o)$ for each $o \in O_2$.
%
%  \end{itemize}
%  where $(m_1(u_1) => v_1) \ll (m_2(u_2) => v_2)$ if{f} $m_1 = m_2$, $u_1 =
%  u_2$, and $v_1 \in \set{ v_2, \bot }$. We say $h_1$ and $h_2$ are
%  \emph{equivalent} when $h_1 \preceq h_2$ and $h_2 \preceq h_1$.
%
%\end{definition}


