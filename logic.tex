%!TEX root = head.tex

\section{Logical Characterizations of Complete Histories}~\label{sec:logic}

We introduce logical characterizations of complete history sets using existentially-quantified
second-order formulas. Essentially, such a formula expresses the fact that the modeled history
is weaker than another history characterized using a first-order formula. When it describes
the set of complete histories $H_c(L)$ of a library $L$ it states that the modeled history is
weaker than another history in the kernel of $L$.
By the following lemma, this is equivalent
to the fact that the modeled history belongs to $H(L)$.

\begin{lemma}\label{lemma:kernel_histories}

Let $h$ be a history and $L$ a library such that $\ker L$ is defined. Then, 
\[
h\in H(L)\mbox{ iff there exists }h'\in H(\ker L)\mbox{ s.t. }h\preceq h'.
\]

\end{lemma}


%, it uses another symbol $<_{\sf k}$.

\begin{figure}
  \begin{align*}
    o,o' & \in \<Ops>
      \qquad \text{operation-identifier constants} \\
     x & : \<Ops>
      \qquad \text{operation-identifier variables} \\
     \vec{x},\vec{y} & : \<Ops>^*
      \qquad \text{tuples of operation-identifier variables} \\
    @l & \in \<Labels>
      \qquad \text{operation labels} \\[2mm]
    X & ::= o \mid x \\
%    T & ::= i \mid \#(X, i, j) \mid T + T \\
    F & ::= @l(X)\mid X=X\mid \<Matching>(X,X) \mid X \poker X \mid \neg F \mid F \land F \\
    \<PO>(\poker) & ::= \forall x.\ \neg x \poker x  \\
    &\land\,\forall x_1,x_2,x_3.\ (x_1\poker x_2\land x_2 \poker x_3) => x_1 \poker x_3 \\
    < \subseteq \hspace{-1mm}\poker & ::= \forall x_1,x_2.\ x_1 < x_2 => x_1 \poker x_2  \\
    \psi  & ::= \exists \poker.\ \big( < \subseteq \hspace{-1mm}\poker 
    \land \<PO>(\poker)\land \forall \vec{x}\ \exists \vec{y}.\ F\, \big)
  \end{align*}
  \caption{The syntax of $\psi_L$.}
  \label{fig:logic}
\end{figure}

The syntax of the formulas $\psi$ we consider for describing sets of complete histories 
is given in Figure~\ref{fig:logic}. Thus, $\psi$ is a second-order
formula that existentially quantifies over a relation $\poker$ and that is a conjunction of:
\begin{itemize}
  \item a formula $\<PO>(\poker)$ expressing the fact that $\poker$ is a strict
  partial order,
  \item a formula expressing the fact that the order relation $<$ in the modeled history 
  is weaker than the order relation $\poker$,
  \item a formula expressing the fact that the set of operations in the modeled history
ordered by $\poker$ forms a history in the kernel of $L$.
\end{itemize} 
The latter sub-formula is a \emph{closed} formula (i.e., without free variables) 
with $\forall^*\exists^*$ quantifier prefix.

The semantics of $\psi$ is defined as usual. The satisfaction relation $\models$ for quantified formulas
is defined by:
\begin{align*}
h\models \exists \poker.\ \psi' & \mbox{ iff $\exists \poker\subseteq O\times O$ s.t. }\tup{h,\poker}\models \psi' \\
\tup{h,\poker}\models \exists x.\ \varphi & \mbox{ iff $\exists o\in O$ s.t. }\tup{h,\poker}\models \varphi [x \mapsto o]
\end{align*}


\begin{example}

Examples of formulas $\psi_L$ for the most common objects.

\todo{add predicates to recognize negative/positive labels}

\newcommand{\ispositive}[1]{L_+({#1})}
\newcommand{\isnegative}[1]{L_{-}({#1})}
\newcommand{\remove}{Rem}
\newcommand{\add}{Add}
\newcommand{\containstrue}{CT}
\newcommand{\containsfalse}{CF}

\begin{itemize}
\item
We define a formula of the form $\exists \forall$ which recognizes histories
which are not in the kernel of the Queue specification. When negated, it can
thus be plugged in place of $\forall \vec{x}\ \exists \vec{y}.\ F$. 

There are three ways a history can violate the Queue specification.
Either it does not form a total order:
\[
  \exists x_1,x_2.
  \ x_1 != x_2 \land \neg (x_1 \poker x_2) \land \neg (x_2 \poker x_1) 
\]
or there is a dequeue operation with no matching enqueue operation which 
precedes it:
\[
  \exists y.\ \isnegative{y} \land 
  \forall x.\ \<Matching>(y,x) \implies y \poker x
\]
or there is a violation of the FIFO order -- that is, there is some enqueue
($x_1$) which happened before another enqueue ($x_2$) such that the dequeue
corresponding to $x_2$ ($y_2$) happened before any dequeue corresponding to
$x_1$ ($y_1$), if any:
\begin{align*}
\exists x_1,x_2,y_2.
  &\ x_1 \poker x_2 \land \<Matching>(y_2,x_2) 
    \land \ispositive{x_1} \land\\
  &\forall y_1.\ 
    \<Matching>(y_1,x_1) \implies y_2 \poker y_1
\end{align*}



\item 
For the Stack, we use the same first two formulas as the Queue. To
recognize LIFO violations, we use a formula similar to the formula recognizing
FIFO violations. 
Note though that we need one more constraint ($x_1 \poker y_2$), since the 
order of operations $x_2 \poker y_2 \land y_2 \poker x_1$ does not yield a
violation of the LIFO order.
\begin{align*}
\exists x_2,x_1,y_2.
  &\ x_2 \poker x_1 \land x_1 \poker y_2 
    \land \<Matching>(y_2,x_2) \land \ispositive{x_1} \land \\
  &\forall y_1.\ 
      \<Matching>(y_1,x_1) \implies y_1 \poker y_2
\end{align*}



\item 
For the Register, we also use the same first two formulas.
The third formula recognize histories where there is a read ($y_2$) with 
no matching write ($x_2$) in between $y_2$ and the preceding write.
\begin{align*}
  \exists x_1,y_2.
    &\ x_1 \poker y_2 \land \ispositive{x_1} \land
      \isnegative{y_2} \land \neg \<Matching>(y_2,x_1) \land\\
    &\forall x_2.\ x_1 \poker x_2 \land x_2 \poker y_1 \implies 
      \neg \<Matching>(y_2,x_2)
\end{align*}



\item
Concerning the set, we still use the same first two formulas. Then we use
two more formulas, one for $\tt contains => true$ violations, 
and one for $\tt contains => false$ violations.

The first one says that there is a $\tt contains => true$ (abbreviated $CT$
for better readability) and a remove, so that there is no add in between.
\begin{align*}
\exists x_r,x_c.\ &
  \remove(x_r) \land \containstrue(x_c)
  \land x_r \poker x_c \land\\
    &\forall x_a.\ x_r \poker x_a \land x_a \poker x_c \implies 
      \neg \<Matching>(x_c,x_a)
\end{align*}

The second one says that there is a $\tt contains => false$ (abbreviated $CF$)
and an add, so that there is no remove in between.
\begin{align*}
\exists x_a,x_c.\ &
  \add(x_a) \land \containsfalse(x_c)
  \land x_a \poker x_c \land\\
   & \forall x_r.\ (x_a \poker x_r \land x_r \poker x_c \land \remove(x_r))
    \implies \\
    &\qquad \neg \<Matching>(x_r,x_a)
\end{align*}

\end{itemize}

\end{example}
