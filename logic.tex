%!TEX root = head.tex

\section{Refinement via Logical Reasoning}
\label{sec:logic}

TODO THIS SECTION MAY NEED ANOTHER PASS

In this section we represent the kernels of typical concurrent objects,
including atomic collections and locks, in a simple first-order language. To
simplify, and avoid having to determine, e.g.,~which operation removes the
instance of a value added by another, we suppose that objects come equipped
with a \emph{matching function} $M$ mapping each history $h = \tup{O,<,f}$ to a
partial function $M_h : O /-> O$ over its operations. Intuitively, $M_h$ maps
operations $o$ which ``remove'' values to the operations $M_h(o)$ which added
them. For instance, the matching function $M_h$ for a history of the atomic
stack object is injective, and maps each $(\<pop> => v_1)$-operation $o$ to a
$\<push>(v_2)$-operation $M_h(o)$ such that $v_1 = v_2$ when $M_h(o)$ is
defined. Similarly, the matching function $M_h$ for an atomic lock object is
also injective, and maps each ${\sf unlock}$-operation $o$ to a
${\sf lock}$-operation $M_h(o)$ if $M_h(o)$ is defined. In
Section~\ref{sec:matching} we demonstrate that such matching functions can be
maintained for all objects of interest, e.g.,~by tagging values with unique
identifiers.

Figures~\ref{fig:formulas:common}--\ref{fig:formulas:synchronization} list the
properties characterizing typical concurrent objects in a first-order language
whose variables range over operation identifiers, and whose functions and
predicates are interpreted over the operation labels and order relation of a
history, and a given object's matching function. We use the function symbols
{\sf meth}-od, {\sf arg}-ument, and {\sf ret}-urn, as well as the predicate
symbols {\sf match} and {\sf b}-efore for this purpose. Note that we interpret
the predicate ${\sf match}(x_1,x_2)$ by $o_1 = M_h(o_2)$ when each $x_i$ binds
to $o_i$. We represent the kernel $H$ of each of the following objects by a
first-order formula $@Y_H$ such that $h \in H$ if{f} $h, M_h |= @Y_H$, where
the satisfaction relation $\_, \_ |= \_$ is defined as usual, using the
aforementioned interpretations.

\begin{figure}
  \footnotesize
  \begin{align*}
    & \textsc{Atomic} \\
    & \forall x_1,x_2.\ 
      {\sf b}(x_1,x_2) \oplus {\sf b}(x_2,x_1) /| \forall x.\ {\sf ret}(x) \neq \bot
    \\
    & \textsc{Injective} \\
    & \forall x, y_1, y_2.\ {\sf match}(x, y_1) /| {\sf match}(x, y_2) => y_1 = y_2
    \\
    & \textsc{Total}(Y) \\
    & \forall y.\ {\sf meth}(y) = Y => \exists x.\ {\sf match}(x,y) /| {\sf b}(x,y)
    \\
    & \textsc{Match1}(X,Y) \\
    & \forall x, y.\ {\sf match}(x,y) => 
        {\sf meth}(x) = X /| {\sf meth}(y) = Y /| {\sf arg}(x) = {\sf ret}(y)
    \\
    & \textsc{Match2}(X,Y) \\
    & \forall x, y.\ {\sf match}(x,y) => 
      {\sf meth}(x) = X /| {\sf meth}(y) = Y /| {\sf arg}(x) = {\sf arg}(y)
    \\
    & \textsc{Match3}(X,Y) \\
      & \forall x, y.\ 
        {\sf match}(x,y) => {\sf meth}(x) = X /| {\sf meth}(y) = Y
  \end{align*}
  \caption{Generic formul\ae used across many objects.}
  \label{fig:formulas:common}
\end{figure}

\begin{example}[Atomic collections]

  Prior work~\cite{conf/tacas/AbdullaHHJR13, conf/concur/HenzingerSV13}
  represents atomic queue objects by the conjunction of properties stating:
  \begin{itemize}

    \item remove operations return distinct\footnote{Appealing to our
    aforementioned use of matching functions, we assume each value is added to
    an atomic collection at most once.} values ({\sc UniqRem}),

    \item values are added before they are removed ({\sc AddRem}),

    \item values are added in the order removed ({\sc Fifo}), and

    \item remove operations returning empty are not surrounded by matching adds
    and removes ({\sc Empty}).

  \end{itemize}
  We thus represent the kernel $H_{\sf q}$ of atomic queues by
  \begin{align*}
    \textsc{Atomic} /| \textsc{UniqRem} /| \textsc{AddRem}
      /| \textsc{Fifo} /| \textsc{Empty}
  \end{align*}
  Similarly, we represent the kernel $H_{\sf pq}$ of priority queues by
  \begin{align*}
    \textsc{Atomic} /| \textsc{UniqRem} /| \textsc{AddRem}
      /| \textsc{Max} /| \textsc{Empty}
  \end{align*}
  and the kernel $H_{\sf st}$ of atomic stacks by
  \begin{align*}
    \textsc{Atomic} /| \textsc{UniqRem} /| \textsc{AddRem}
      /| \textsc{Lifo} /| \textsc{Empty}
  \end{align*}
  Additionally, we enforce the sanity of the underlying matching function by
  adding the formul\ae $\textsc{Injective}$ and $\textsc{Match1}({\sf add},{\sf
  rem})$, ensuring removes are matched to adds adding the removed value.

\end{example}

\begin{figure}
  \footnotesize
  \begin{align*}
    & \textsc{UniqRem} \\
      & \forall r_1, r_2.\
        {\sf meth}(r_1) = {\sf meth}(r_2) = {\sf rem} /|
        {\sf ret}(r_1) = {\sf ret}(r_2) => r_1 = r_2
    \\
    & \textsc{AddRem} \\
    & \forall r.\ {\sf meth}(r) = {\sf rem} /| {\sf ret}(r) \neq {\sf empty} =>
      \exists a.\ {\sf match}(a,r) /| {\sf b}(a,r)
    \\
    & \textsc{Empty} \\
    & \forall e, a.\ {\sf meth}(e) = {\sf rem} /| {\sf ret}(e) = {\sf empty} /| {\sf meth}(a) = {\sf add} \\
    & \quad /| {\sf b}(a,e) => \exists r.\ {\sf match}(a,r) /| {\sf b}(r,e)
    \\
    & \textsc{Fifo} \\
    & \forall a_1, a_2, r_2.\ {\sf meth}(a_1) = {\sf add} /| {\sf match}(a_2,r_2) \\
    & \quad /| {\sf b}(a_1,a_2) =>\exists r_1.\ {\sf match}(a_1,r_1) /| {\sf b}(r_1,r_2)
    \\
    & \textsc{Lifo} \\
    & \forall a_1, a_2, r_1.\ {\sf meth}(a_2) = {\sf add} /| {\sf match}(a_1,r_1) \\
    & \quad /| {\sf b}(a_1,a_2) /| {\sf b}(a_2,r_1) => \exists r_2.\ {\sf match}(a_2,r_2) /| {\sf b}(r_2,r_1)
    \\
    & \textsc{Max} \\
    & \forall a_1, a_2, r_1.\ {\sf meth}(a_2) = {\sf add} /| {\sf match}(a_1,r_1) /| {\sf b}(a_2,r_1) \\
    & \quad /| {\sf arg}(a_1) < {\sf arg}(a_2) => \exists r_2.\ {\sf match}(a_2,r_2) /| {\sf b}(r_2,r_1)
  \end{align*}
  \caption{Formul\ae for collection objects.}
  \label{fig:formulas:collecions}
\end{figure}

%\item
%For the Set, we use two formulas, one for $\tt contains => true$ violations, 
%and one for $\tt contains => false$ violations.
%
%The first one says that there is a $\tt contains => true$  ($c$)
%and a remove, so that there is no add in between.
%\begin{align*}
%\exists r,c.\ &
%  {\sf remove}(r) /| {\sf contains}(c) /| \rval{c} = {\sf true}
%  /| r \poker c /|\\
%    &\forall a.\ r \poker a /| a \poker c \implies 
%      \neg \<Matching>(c,a)
%\end{align*}
%
%The second one says that there is a $\tt contains => false$ (abbreviated $CF$)
%and an add, so that there is no remove in between.
%\begin{align*}
%\exists a,c.\ &
%  {\sf add}(a) /| \containsfalse(c)
%  /| a \poker c /|\\
%   & \forall r.\ (a \poker r /| r \poker c /| {\sf remove}(r))
%    \implies \\
%    &\qquad \neg \<Matching>(r,a)
%\end{align*}

\begin{example}[Atomic sets]

  Unlike the atomic queues and stacks which behave as \emph{multisets} and
  return removed values, the atomic set's {\sf remove} method takes as an
  argument a value to be removed, and succeeds whether or not the value is
  present. The formul\ae {\sc Include*} and {\sc Exclude} specify when a {\sf
  contains}-operation may return {\sf true}. We represent the kernel $H_{\sf s}$
  of atomic sets by  
  \begin{align*}
    \textsc{Atomic} /| \textsc{Include} /| \textsc{Exclude}
  \end{align*}
  Additionally, we enforce the sanity of the underlying matching function by
  adding the formul\ae $\textsc{Injective}$ and $\textsc{Match2}({\sf add},{\sf
  rem})$, ensuring removes are matched to adds adding the removed value.

\end{example}

\begin{figure}
  \footnotesize
  \begin{align*}
    & \textsc{MatchingAdd} \\
    & \forall a,rc,p.\ {\sf match}(rc,a) /| {\sf arg}(p) = {\sf arg}(a) \\
    & \quad /| \forall q.\ {\sf b}(q,p) \vee {\sf b}(a,q) \vee {\sf arg}(q)\neq {\sf arg}(a) \\
    & \quad => {\sf meth}(p)={\sf remove} \vee ({\sf meth}(p)={\sf contains} /| {\sf ret}(p) = {\sf false}) 
    \\
    & \textsc{MatchingRem} \\
    & \forall a,r.\ {\sf match}(r,a) /| {\sf meth}(r) = {\sf remove}  => {\sf meth}(a)={\sf add} /| {\sf b}(a,r) \\
    & \forall a,r,p.\ {\sf match}(r,a) /| {\sf arg}(p) = {\sf arg}(r) /| {\sf meth}(r)={\sf remove}\\
    & \quad /| \forall q.\ {\sf b}(q,p) \vee {\sf b}(r,q) \vee {\sf arg}(q)\neq {\sf arg}(r) \\
    & \quad => {\sf meth}(p)={\sf add} \vee ({\sf meth}(p)={\sf contains} /| {\sf ret}(p) = {\sf true}) 
    \\   
    & \textsc{Include} \\
    & \forall c.\ {\sf meth}(c) = {\sf contains} /| {\sf ret}(c) = {\sf true} \\
    & \quad => \exists a.\ {\sf match}(c,a) /| {\sf b}(a,c) \\
    & \forall c,a,r.\ {\sf meth}(c)={\sf contains} /| {\sf ret}(c) = {\sf true} \\
    & \quad /| {\sf meth}(r) = {\sf remove}/| {\sf meth}(a) = {\sf add} /|  {\sf match}(c,a) /| {\sf match}(r,a)  \\ %{\sf arg}(c) = {\sf arg}(r) = {\sf arg}(a) \\
    & \quad => {\sf b}(a,c) /| {\sf b}(c,r)
    \\
    & \textsc{Exclude} \\
    & \forall c,a.\ {\sf meth}(c)={\sf contains} /| {\sf ret}(c) = {\sf false} \\
    & \quad /| {\sf meth}(a) = {\sf add}/| {\sf arg}(c) = {\sf arg}(a) /| {\sf b}(a,c) \\
    & \quad => \exists r.\ {\sf meth}(r)={\sf remove} /| {\sf match}(r,a) /| {\sf b}(r,c)
  \end{align*}
  \caption{Formul\ae for set objects.}
  \label{fig:formulas:set}
\end{figure}

\begin{example}[Atomic register]

  Atomic registers with {\sf read} and {\sf write} methods essentially ensure
  that each value read is written by the most recent {\sc write}-operation.
  We represent the kernel $H_{\sf r}$ of atomic registers by
  \begin{align*}
    \textsc{Atomic} /| \textsc{ReadWrite} /| \textsc{ReadFrom}
  \end{align*}
  and enforce the sanity of the underlying matching function by adding the
  formul\ae $\textsc{Injective}$ and $\textsc{Match1}({\sf write},{\sf read})$,
  ensuring reads are matched to writes writing the read value.

\end{example}

\begin{figure}
  \footnotesize
  \begin{align*}
    & \textsc{ReadWrite} \\
    & \forall r.\ {\sf meth}(r) = {\sf read} => \exists w.\ {\sf match}(w,r) /| {\sf b}(w,r)
    \\
    & \textsc{ReadFrom} \\
    & \forall w_1, r.\ {\sf meth}(w_1) = {\sf write} /| {\sf meth}(r) = {\sf read} /| \neg {\sf match}(w_1,r) \\
    & \quad /| {\sf b}(w_1,r) => \exists w_2.\ {\sf match}(w_2,r) /| {\sf b}(w_1,w_2) /| {\sf b}(w_2,r)
  \end{align*}
  \caption{Formul\ae for register objects.}
  \label{fig:formulas:register}
\end{figure}

\begin{example}[Synchronization objects]

  Atomic lock objects with {\sf lock} and {\sf unlock} methods ensure that at
  most one thread holds a lock at any moment. We represent the kernel of atomic
  locks by
  \begin{align*}
    \textsc{Atomic} /| \textsc{Total}({\sf unlock}) /| \textsc{Mutex}
  \end{align*}
  and enforce coherent matching by adding the formul\ae $\textsc{Match3}({\sf
  lock},{\sf unlock})$ and $\textsc{Injective}$.
  Atomic semaphore objects with {\sf acquire} and {\sf release} methods generalize
  atomic locks, ensuring that at most $n$ copies of a resource are held at any
  moment, for some fixed $n \in \<Nats>$. We represent the kernel of atomic
  semaphores by
  \begin{align*}
    \textsc{Atomic} /| \textsc{Total}({\sf release}) /| \textsc{Limit}
  \end{align*}
  and enforce coherent matching by adding the fomrul\ae 
  $\textsc{Match3}({\sf acquire},{\sf release})$ and $\textsc{Injective}$.

\end{example}

\begin{figure}
  \footnotesize
  \begin{align*}
    & \textsc{Mutex} \\
    & \forall @l_1, @l_2.\ {\sf meth}(@l_1) = {\sf meth}(@l_2) = {\sf lock} /| {\sf b}(@l_1,@l_2) \\
    & \quad => \exists u.\ {\sf meth}(u) = {\sf unlock} /| {\sf b}(@l_1,u) /| {\sf b}(u,@l_2)
    \\
    & \textsc{Limit} \\
    & \forall x_0,\dots,x_n.\ \bigwedge_{0 \leq i < n} {\sf b}(x_i,x_n) /| \bigwedge_{0 \leq i \leq n} {\sf meth}(x_i) = {\sf acquire} \\
    & \quad=> \exists r.\ {\sf b}(r,x_n) /| \bigvee_{0 \leq i \leq n} {\sf match}(y,x_i)
    \\
    & \textsc{Exchange} \\
    & \forall x.\ {\sf ret}(x)\neq \bot \\
    & \forall x_1,x_2.\ {\sf match}(x_1,x_2) => \neg {\sf b}(x_1,x_2) /| \neg {\sf b}(x_2,x_1) \\
    & \textsc{Injective} \\
		& \forall x_1,x_2.\ {\sf match}(x_1,x_2) \Leftrightarrow {\sf match}(x_2,x_1) \\
		& \forall x.\ {\sf ret}(x) \neq {\sf null} =>  \exists y.\ {\sf match}(x,y)  \\
		& \forall x,y.\ {\sf match}(x,y) => {\sf ret}(x) = {\sf arg}(y)
  \end{align*}
  \caption{Formul\ae for synchronization objects.}
  \label{fig:formulas:synchronization}
\end{figure}

\begin{example}[Exchanger]

  TODO REVIEW THE FOLLOWING

  Exchanger objects are used to pair up threads so they can atomically swap
  values. The only method of this object is $\<exchange>$ which receives as
  input a value $v$ that a thread it offers to swap and returns a value $v'\neq
  {\sf null}$ if it has paired up with an $\<exchange>(v')$ operation. The latter
  operation will return the value $v$. Since the time spans of $\<exchange>$
  operations that pair up overlap in time, the basis of this object contains
  complete histories which are not necessarily sequential. They are described
  by the formula $\<Exchanger>$ in Figure~\ref{fig:examples_formulas} which
  states that the matching function defines a one to one correspondence between
  overlapping $\<exchange>$ operations, that every operation returning a value
  different from ${\sf null}$ must match another operation, and that every two
  matched operations must return the argument of their counterpart.

\end{example}



%The following result follows easily from definitions.


%%, it uses another symbol $<_{\sf k}$.
%
%
%The syntax of the formulas $\psi$ we consider for describing sets of complete histories 
%is given in Figure~\ref{fig:logic}. Thus, $\psi$ is a second-order
%formula that existentially quantifies over a relation $\poker$ and that is a conjunction of:
%\begin{itemize}
%  \item a formula $\<PO>(\poker)$ expressing the fact that $\poker$ is a strict
%  partial order,
%  \item a formula expressing the fact that the order relation $<$ in the modeled history 
%  is weaker than the order relation $\poker$,
%  \item a formula expressing the fact that the set of operations in the modeled history
%ordered by $\poker$ forms a history in the kernel of $L$.
%\end{itemize} 
%The latter sub-formula is a \emph{closed} formula (i.e., without free variables) 
%with $\forall^*\exists^*$ quantifier prefix.
%
%The semantics of $\psi$ is defined as usual. The satisfaction relation $\models$ for quantified formulas
%is defined by:
%\begin{align*}
%h\models \exists \poker.\ \psi' & \mbox{ iff $\exists \poker\subseteq O\times O$ s.t. }\tup{h,\poker}\models \psi' \\
%%\tup{h,\poker}\models \exists x.\ \varphi & \mbox{ iff $\exists o\in O$ s.t. }\tup{h,\poker}\models \varphi [x \mapsto o]
%\end{align*}


