%!TEX root = head.tex

\newcommand{\noexc}{\<null>}

\section{Logical Characterizations of Library Bases}~\label{sec:logic}

For the common reference implementations used in practice, e.g., atomic objects,
their library bases can be naturally described in 
first-order logic. The language used by these logical characterizations contains  
variables interpreted as operation identifiers, several function symbols that return
the method or the arguments of an operation, a binary predicate $\<match>$
interpreted as the matching function, and a binary predicate $\<b>$ interpreted
as the order relation in the modeled history. The  function symbols $\<meth>$, $\<arg>$, and $\<ret>$
return the method, the argument, and respectively the return value of
an operation.

\begin{figure*}
{\small
\begin{align*}
\<Sequential> & \triangleq \forall x_1,x_2.\ \<b>(x_1,x_2)\oplus \<b>(x_2,x_1) \land \forall x.\ \<ret>(x)\neq \bot \\
\<Match>_1(\<rem>,\<add>) & \triangleq \forall x_r,x_a.\ \<match>(x_r,x_a) => (\<meth>(x_r)=\<rem>\land \<meth>(x_a)=\<add>\land \<ret>(x_1)=\<arg>(x_2)) \\ %
\<Injective> & \triangleq \forall x_1,x_2,x.\ (\<match>(x_1,x)\land \<match>(x_2,x)) => x_1=x_2 \\ %\land \<ret>(x_1)=\<arg>(x_2)
\<Remove>& \triangleq \forall x_r.\ (\<meth>(x_r)=\<rem> \land \<ret>(x_r)\neq \<empty>)=> \exists y_a.\ \<match>(x_r,y_a)\land \<b>(y_a,x_r) \\ %\land \<ret>(x_r)=\<arg>(y_a)
\<Empty>& \triangleq \forall x_e,x_a.\ (\<meth>(x_e)=\<rem> \land \<ret>(x_e)=\<empty>\land \<meth>(x_a)=\<add>\land \<b>(x_a,x_e)) \\
&\hspace{9cm}=> \exists y_r.\ \<match>(y_r,x_a)\land \<b>(y_r,x_e) \\
\<Multiset> & \triangleq \<Sequential>\land \<Match>_1(\<rem>,\<add>)\land \<Injective>\land \<Remove>\land \<Empty> \\
\<Fifo>& \triangleq \forall x_a,x'_a,x_r'.\ (\<meth>(x_a)=\<add> \land \<match>(x_r',x_a') \land \<b>(x_a,x_a')) => \exists y_r.\ \<match>(y_r,x_a)\land \<b>(y_r,x_r') \\
\<Lifo>& \triangleq \forall x_a,x_a',x_r.\ (\<meth>(x_a')=\<add> \land \<match>(x_r,x_a)\land \<b>(x_a,x_a') \land \<b>(x_a',x_r)) => \exists y_r.\ \<match>(y_r,x_a')\land \<b>(y_r,x_r) \\
\<Max>& \triangleq \forall x_a,x_a',x_r.\ (\<meth>(x_a')=\<add> \land \<match>(x_r,x_a) \land \<b>(x_a',x_r)\land \<arg>(x_a)<\<arg>(x_a')) 
=> \exists y_r.\ \<match>(y_r,x_a')\land \<b>(y_r,x_r) \\[2mm]
\<Match>_2(\<rem>,\<add>) & \triangleq \forall x_r,x_a.\ \<match>(x_r,x_a) => (\<meth>(x_r)=\<rem>\land \<meth>(x_a)=\<add>\land \<arg>(x_1)=\<arg>(x_2)) \\ %\land \<ret>(x_1)=\<arg>(x_2)
\<ContainsTrue>& \triangleq  \forall x_c.\ (\<meth>(x_c)=\<contains> \land \<ret>(x_c)=\<true>)=> \exists y_a.\ \<meth>(y_a)=\<add>\land \<arg>(y_a)=\<arg>(x_c)\land \<b>(y_a,x_c) \\
& \hspace{4mm}\land\ \forall x_c,x_r.\ (\<meth>(x_c)=\<contains> \land \<ret>(x_c)=\<true>\land \<meth>(x_r)=\<rem>\land \<arg>(x_c)=\<arg>(x_r)\land \<b>(x_r,x_c)) \\
&\hspace{5cm}=> \exists y_a.\ \<meth>(y_a)=\<add>\land\<arg>(x_c)=\<arg>(y_a)\land \<b>(x_r,y_a)\land \<b>(y_a,x_c) \\
\<ContainsFalse>&\triangleq \forall x_c,x_a.\ (\<meth>(x_c)=\<contains> \land \<ret>(x_c)=\<false>\land \<meth>(x_a)=\<add>\land \<arg>(x_c)=\<arg>(x_a)\land \<b>(x_a,x_c)) \\
&\hspace{5cm}=> \exists y_r.\ \<meth>(y_r)=\<remove>\land\<arg>(x_c)=\<arg>(y_r)\land \<b>(y_r,x_c) \\
\<Set> & \triangleq \<Sequential>\land\<Match>_2(\<rem>,\<add>)\land \<Injective>\land \<ContainsTrue>\land \<ContainsFalse> \\[2mm]
%\<Match(reg)> & \triangleq \forall x_r,x_w.\ \<match>(x_r,x_w) => (\<meth>(x_r)=\<read>\land \<meth>(x_w)=\<write>\land \<ret>(x_r)=\<arg>(x_w)) \\
\<Read>& \triangleq \forall x_r.\ \<meth>(x_r)=\<read> => \exists y_w.\ \<match>(x_r,y_w)\land \<b>(y_w,x_r) \\
\<ReadFrom>& \triangleq \forall x_w,x_r.\ (\<meth>(x_w)=\<write> \land \<meth>(x_r)=\<read>\land \neg \<match>(x_r,x_w)\land \<b>(x_w,x_r)) \\
&\hspace{5cm}=> \exists y_w.\ \<match>(x_r,y_w)\land \<b>(x_w,y_w)\land \<b>(y_w,x_r) \\ %\land \<ret>(x_r)=\<arg>(y_w)
\<Register> & \triangleq \<Sequential>\land \<Match>_1(\<read>,\<write>)\land \<Read>\land \<ReadFrom> \\[2mm]
\<Match>_3(\<unlock>,\<lock>) & \triangleq \forall x_u,x_l.\ \<match>(x_u,x_l) => (\<meth>(x_u)=\<unlock>\land \<meth>(x_l)=\<lock>) \\ %\land \<ret>(x_1)=\<arg>(x_2)
\<Total>(\<unlock>)& \triangleq \forall x_u.\ \<meth>(x_u)=\<unlock> => \exists y_l.\ \<match>(x_u,y_l)\land \<b>(y_l,x_u) \\ %\land \<ret>(x_r)=\<arg>(y_a)
\<NoSuccLocks>& \triangleq \forall x_l,x_l'.\ (\<meth>(x_l)=\<lock>\land \<meth>(x_l')=\<lock>\land \<b>(x_l,x_l')) => \exists y.\ \<b>(x_l,y)\land \<b>(y,x_l') \\
\<Lock> & \triangleq \<Sequential>\land \<Match>_3(\<unlock>,\<lock>)\land \<Injective> \land\<Total>(\<unlock>)\land \<NoSuccLocks>  \\[2mm]
\<TooManyAcq> & \triangleq \forall x_0,\dots,x_\capacity.\ 
  \big(\bigwedge_{0 \leq i < \capacity} \<b>(x_i,x_\capacity) \land
  \bigwedge_{0 \leq i \leq \capacity} \<meth>(x_i)=\<acquire> \big) 
	 =>
   \exists y.\ y \poker x_\capacity \land 
    \bigvee_{0 \leq i \leq \capacity} \<match>(y,x_i) \\
\<Semaphore> & \triangleq \<Sequential>\land \<Match>_3(\<release>,\<acquire>)\land \<Injective>\land \<Total>(\<release>)\land \<TooManyAcq> \\[2mm]
\<Exchanger> & \triangleq \big(\forall x.\ \<ret>(x)\neq \bot\big) \land \big(\forall x_1,x_2.\ \<match>(x_1,x_2) => \neg \<b>(x_1,x_2)\land \neg \<b>(x_2,x_1)\big)  \\
				& \land \big(\forall x,x_1,x_2.\ \neg (\<match>(x_1,x) \land \<match>(x_2,x))\big)
				\land\ \big(\forall x.\ \<ret>(x) \neq \<null> =>  \exists y.\ \<match>(y,x) \vee \<match>(x,y)\big) \\
				& \land \big(\forall x,y.\ (\<match>(y,x) \lor \<match>(x,y)) => \<ret>(x) =\<arg>(y)\big)			
\end{align*}
}
\caption{Logical characterizations of common reference implementations.}
\label{fig:examples_formulas}
\end{figure*}

\begin{example}[Atomic multisets]

The bases of atomic collections that store a multiset of values, e.g., queues, priority queues, and stacks, 
can be characterized using conjunctions of formulas
in Figure~\ref{fig:examples_formulas}. Thus, the basis of an atomic queue is described by the formula
$\<Multiset>\land \<Fifo>$, which states that it consists of complete sequential histories ($\<Sequential>$),
the matching function maps remove operations to add operations ($\<Match>_1(\<rem>,\<add>)$),
no two non-empty removes return the same value ($\<Injective>$),
for every remove returning $v\neq \<empty>$ there exists a preceding matching add with input $v$ ($\<Remove>$),
for every remove $x_e$ returning $\<empty>$ and every preceding $\<add>$ $x_a$ there exists a $\<remove>$ matching 
$x_a$ which precedes $x_e$ ($\<Empty>$),
and the values are removed in the lifo order ($\<Fifo>$), i.e., for every two adds $x_a$ ordered before $x_a'$ and 
every remove $x_r'$ matching the second add $x_a'$,
there exists a remove $x_r$ matching $x_a$ which is ordered before $x_r'$ .

For atomic stacks, the sub-formula $\<Fifo>$ is replaced with $\<Lifo>$ which states that the values
are removed in the lifo order while for atomic priority queues, the sub-formula $\<Fifo>$ is replaced
with $\<Max>$ which states that a remove returns the maximal value in the collection.

\end{example}

%\item
%For the Set, we use two formulas, one for $\tt contains => true$ violations, 
%and one for $\tt contains => false$ violations.
%
%The first one says that there is a $\tt contains => true$  ($x_c$)
%and a remove, so that there is no add in between.
%\begin{align*}
%\exists x_r,x_c.\ &
%  \<remove>(x_r) \land \<contains>(x_c) \land \rval{x_c} = \<true>
%  \land x_r \poker x_c \land\\
%    &\forall x_a.\ x_r \poker x_a \land x_a \poker x_c \implies 
%      \neg \<Matching>(x_c,x_a)
%\end{align*}
%
%The second one says that there is a $\tt contains => false$ (abbreviated $CF$)
%and an add, so that there is no remove in between.
%\begin{align*}
%\exists x_a,x_c.\ &
%  \<add>(x_a) \land \containsfalse(x_c)
%  \land x_a \poker x_c \land\\
%   & \forall x_r.\ (x_a \poker x_r \land x_r \poker x_c \land \<remove>(x_r))
%    \implies \\
%    &\qquad \neg \<Matching>(x_r,x_a)
%\end{align*}


\begin{example}[Atomic sets]

The basis of an atomic set is characterized by the formula $\<Set>$ in Figure~\ref{fig:examples_formulas}.
As opposed to the atomic multisets, $\<Set>$ doesn't 
require that every remove operation matches an add operation, as 
a remove can succeed even though the element was already removed from 
the set. The formula $\<ContainsTrue>$, resp., $\<ContainsFalse>$, states that a contains operation 
returns $\<true>$, resp., $\<false>$, only if the element is present, resp., absent from the set.

\end{example}

\begin{example}[Atomic register]

The basis of an atomic register is characterized by the formula $\<Register>$ in Figure~\ref{fig:examples_formulas},
which states that the matching function maps read operations to write operations ($\<Match>_1(\<read>,\<write>)$), 
for every read there exists a preceding matching write ($\<Read>$),
for every read $x_r$ preceded by a non-matching write $x_w$ there exists a preceding matching write $y_w$
which occurs after $x_w$ ($\<ReadFrom>$). In this case the matching function is not necessarily injective
since two read operations may return the value written by the same write operation.

\end{example}

\begin{example}[Synchronization objects]

The formula $\<Lock>$ in Figure~\ref{fig:examples_formulas} describing the basis of a lock object
states that the matching function maps unlock operations to lock operations ($\<Match>_3(\<unlock>,\<lock>)$),
that every unlock operation is mapped to a lock operation ($\<Total>$), 
and that there are no two successive $\<lock>$ operations ($\<NoSuccLocks>$). The basis of a semaphore of fixed capacity $\capacity$
is characterized by the formula $\<Semaphore>$ in Figure~\ref{fig:examples_formulas}. It states that 
$\<release>$ operations are matched with $\<acquire>$ operations and that every sequence
of $c+1$ $\<acquire>$ operations is interrupted by at least one $\<release>$ operation ($\<TooManyAcq>$).

\end{example}

\begin{example}[Exchanger]

Exchanger objects are used to pair up threads so they can atomically swap values. The only 
method of this object is $\<exchange>$ which receives as input a value $v$ that a thread it offers to swap
and returns a value $v'\neq \<null>$ if it has paired up with an $\<exchange>(v')$ operation. The
latter operation will return the value $v$.
Since the time spans of $\<exchange>$ operations that pair up overlap in time, the basis of this object contains complete histories which are not
necessarily sequential. They are described by the formula $\<Exchanger>$ in Figure~\ref{fig:examples_formulas}
which states that the matching function defines a one to one correspondence between overlapping 
$\<exchange>$ operations, that every operation returning a value different from $\<null>$ must match another
operation, and that every two matched operations must return the argument of their counterpart.

\end{example}



%The following result follows easily from definitions.


%%, it uses another symbol $<_{\sf k}$.
%
%
%The syntax of the formulas $\psi$ we consider for describing sets of complete histories 
%is given in Figure~\ref{fig:logic}. Thus, $\psi$ is a second-order
%formula that existentially quantifies over a relation $\poker$ and that is a conjunction of:
%\begin{itemize}
%  \item a formula $\<PO>(\poker)$ expressing the fact that $\poker$ is a strict
%  partial order,
%  \item a formula expressing the fact that the order relation $<$ in the modeled history 
%  is weaker than the order relation $\poker$,
%  \item a formula expressing the fact that the set of operations in the modeled history
%ordered by $\poker$ forms a history in the kernel of $L$.
%\end{itemize} 
%The latter sub-formula is a \emph{closed} formula (i.e., without free variables) 
%with $\forall^*\exists^*$ quantifier prefix.
%
%The semantics of $\psi$ is defined as usual. The satisfaction relation $\models$ for quantified formulas
%is defined by:
%\begin{align*}
%h\models \exists \poker.\ \psi' & \mbox{ iff $\exists \poker\subseteq O\times O$ s.t. }\tup{h,\poker}\models \psi' \\
%%\tup{h,\poker}\models \exists x.\ \varphi & \mbox{ iff $\exists o\in O$ s.t. }\tup{h,\poker}\models \varphi [x \mapsto o]
%\end{align*}


