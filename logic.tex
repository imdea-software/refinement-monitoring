%!TEX root = head.tex

\section{Logical Characterizations of Library Bases}~\label{sec:logic}

We show that sets of histories 

History sets can be characterized using the fragment of the
FO theory of partial orders 
%We introduce logical characterizations of history sets using quantified
%formulas $\psi$ in the first-order theory of partial orders. 
%The syntax of these
%formulas is 
defined in Figure~\ref{fig:logic}, called \emph{history logic}. Essentially, history formulas
have a $\forall^*\exists^*$ quantifier prefix, they use several 
predicates on operation labels, a symbol $\poker$ denoting
the partial order from the modeled history, and a symbol 
$\<Matching>$ denoting the matching relation. By an abuse of notation,
every method name is also a unary predicate denoting the fact that an operation
is an instance of that method. Also, $\<Val>(o_1,o_2)$ holds iff the
output value of $o_1$ equals the input value of $o_2$.
%The semantics of $\psi$ is defined as usual. 
%In particular, 
Formally, given $h=(O,<,f)$~\footnote{We omit the obvious cases from the definition of $\models$.}
%The satisfaction relation $\models$ for some of the operators is defined by:
\begin{align*}
h\models m(o) &\mbox{ iff $f(o)=m(u)=>v$, for some $u$ and $v$}\\
h\models \<Val>(o,o') &\mbox{ iff $f(o)=m(u)=>v$, $f(o')=m'(u')=>v'$} \\
&\hspace{6mm}\mbox{and $v=u'$}\\
h\models o\poker o' &\mbox{ iff $o<o'$} \\
%h\models \exists \poker.\ \psi' & \mbox{ iff $\exists \poker\subseteq O\times O$ s.t. }\tup{h,\poker}\models \psi' \\
h\models \exists x.\ \varphi & \mbox{ iff $\exists o\in O$ s.t. }\tup{h,\poker}\models \varphi [x \mapsto o]
\end{align*}

\begin{figure}
  \begin{align*}
    o,o' & \in \<Ops>
      \qquad \text{operation-identifier constants} \\
     x & : \<Ops>
      \qquad \,\text{\ operation-identifier variables} \\
     \vec{x},\vec{y} & : \<Ops>^*
      \qquad \text{tuples of operation-identifier variables} \\
    m & \in \<Methods>
      \qquad \text{methods} \\[2mm]
    X & ::= o \mid x \\
%    T & ::= i \mid \#(X, i, j) \mid T + T \\
    F & ::= m(X)\mid \<Val>(X,X)\mid X=X\mid \<Matching>(X,X) \\
    &\hspace{6mm}\mid X \poker X \mid \neg F \mid F \land F \\
%    \<PO>(\poker) & ::= \forall x.\ \neg x \poker x  \\
%    &\land\,\forall x_1,x_2,x_3.\ (x_1\poker x_2\land x_2 \poker x_3) => x_1 \poker x_3 \\
%    < \subseteq \hspace{-1mm}\poker & ::= \forall x_1,x_2.\ x_1 < x_2 => x_1 \poker x_2  \\
    \psi  & ::= \forall \vec{x}\ \exists \vec{y}.\ F
  \end{align*}
  \caption{The syntax of $\psi$.}
  \label{fig:logic}
\end{figure}

A history formula describing the set of histories $H(B)$ 
of a library basis $B$ is considered a specification for the entire library.
%
%Since every execution of a library $L$ can be obtained through the $~>$ rewriting 
%from an execution of a given basis $B$, 

\begin{definition}

A formula $\psi$ \emph{represents} $L$ iff there exists a basis $B$ of $L$ such that 
for every history $h$, $h\in H(B)$ iff $h\models \psi$.

\end{definition}

Since $\psi$ is required to characterize only histories of a basis of $L$, there are
histories of $L$ that don't satisfy $\psi$. However, for every history of $L$ there
exists a stronger history which satisfies $\psi$.

%The following result follows easily from definitions.

\begin{theorem}\label{lemma:kernel_histories}

Let $h$ be a history and $\psi$ a formula representing a library $L$. Then, 
\[
h\in H(L)\mbox{ iff there exists a history $h'$ s.t. }h\preceq h'\mbox{ and }h'\models\psi.
\]

\end{theorem}

\begin{proof}
Let $B$ be the basis of $L$
such that $h\in H(B)$ iff $h\models \psi$.

($=>$) By hypothesis, $h$ is the history of an execution $e\in L$.  By definition, there exists
an execution $e'\in B$ such that $e' ~> e$. From the definition of $~>$ it follows that $H(e)\preceq H(e')$.
Since $\psi$ represents $L$, $H(e')\models\psi$ which concludes the proof.

%($\Leftarrow$) Since $h'\models\psi$, $h'$ is the history of an execution $e\in B$. Furthermore,
% $h\preceq h'$ implies that $h$ is the history of an execution $e'$ such that $e~>e'$. Therefore,
% since $B$ is a basis of $L$, we get that $e'\in L$ and $h\in H(L)$.

($\Leftarrow$) Since $h'\models\psi$, $h'$ is the history of an execution $e\in B$. Furthermore,
 $h\preceq h'$ implies that there exists an injection $g: O_h' \rightarrow O_h$ with the 
properties of Definition~\ref{def:weaker_than}. 

Let $O_p$ be the set of operations which were pending in $h$ but are completed in $h'$.
Using the closure properties of Definition~\ref{def:library}, we move all the return
events of the operations in $O_p$ to the end of the execution $e'$ to get an 
execution $e'_1 \in L$.
Then, using the prefix closure, we get rid of these return events, to obtain an 
execution $e'_2$.

Some operations were pending in $h$ and do not appear in $h'$. The closure
properties of Definition~\ref{def:library} allow us to add the call events corresponding
to these operations in $e'_2$ in order to obtain an execution $e'_3 \in L$.

Finally, we have an execution $e'_3$ whose operations are exactly the ones of $h$.
However $h$ might still be weaker than the history of $e'_3$. Still using the same 
closure properties, we can move call events to the left, and return events to the right
in order to obtain a history $e \in L$ corresponding exactly to $h$, which shows
that $h \in H(L)$.
\end{proof}

%%, it uses another symbol $<_{\sf k}$.
%
%
%The syntax of the formulas $\psi$ we consider for describing sets of complete histories 
%is given in Figure~\ref{fig:logic}. Thus, $\psi$ is a second-order
%formula that existentially quantifies over a relation $\poker$ and that is a conjunction of:
%\begin{itemize}
%  \item a formula $\<PO>(\poker)$ expressing the fact that $\poker$ is a strict
%  partial order,
%  \item a formula expressing the fact that the order relation $<$ in the modeled history 
%  is weaker than the order relation $\poker$,
%  \item a formula expressing the fact that the set of operations in the modeled history
%ordered by $\poker$ forms a history in the kernel of $L$.
%\end{itemize} 
%The latter sub-formula is a \emph{closed} formula (i.e., without free variables) 
%with $\forall^*\exists^*$ quantifier prefix.
%
%The semantics of $\psi$ is defined as usual. The satisfaction relation $\models$ for quantified formulas
%is defined by:
%\begin{align*}
%h\models \exists \poker.\ \psi' & \mbox{ iff $\exists \poker\subseteq O\times O$ s.t. }\tup{h,\poker}\models \psi' \\
%%\tup{h,\poker}\models \exists x.\ \varphi & \mbox{ iff $\exists o\in O$ s.t. }\tup{h,\poker}\models \varphi [x \mapsto o]
%\end{align*}


\begin{example}

Examples of formulas $\psi_L$ for the most common objects.
\newcommand{\emptyval}{\bot}
\newcommand{\noexc}{-1}

\begin{itemize}
\item
We define a formula of the form $\exists \forall$ which recognizes histories
which are not in the kernel of the Queue specification. When negated, it 
becomes of the form $\forall \exists$, as we wish.

There are five ways a history can violate the Queue specification.
Either it does not form a total order:
\[
  \exists x_1,x_2.
  \ x_1 != x_2 \land \neg (x_1 \poker x_2) \land \neg (x_2 \poker x_1) 
\]
or the \<Matching> relation doesn't relate \<dequeue> to \<enqueue>'s
\[
	\exists x,y.\ \<Matching>(y,x) \land \neg (\<dequeue>(y) \land \<enqueue>(x))
\]
or there is a \<dequeue> operation which didn't return $\emptyval$ ($y$) but which
has no matching \<enqueue> operation ($x$) which precedes it:
\[
  \exists y.\ \<dequeue>(y) \land \rval{y} \neq \emptyval \land
  \forall x.\ \<Matching>(y,x) \implies y \poker x
\]
or there is dequeue which returned $\emptyval$ ($x_e$) while there was some \<enqueue> 
($x$) which was not dequeued by a corresponding \<dequeue> ($y$).
\begin{align*}
\exists x, x_e.&\ x \poker x_e \land \<dequeue>(x_e) \land \rval{x_e} = \emptyval \land \\&
\<enqueue>(x) \land
\forall y.\ y \poker x_e \implies \neg \<Matching>(y,x)
\end{align*}
or there is a violation of the FIFO order -- that is, there is some enqueue
($x_1$) which happened before another enqueue ($x_2$) such that the dequeue
corresponding to $x_2$ ($y_2$) happened before any dequeue corresponding to
$x_1$ ($y_1$), if any:
\begin{align*}
\exists x_1,x_2,y_2.
  &\ x_1 \poker x_2 \land \<Matching>(y_2,x_2) 
    \land \<enqueue>(x_1) \land\\
  &\forall y_1.\ 
    \<Matching>(y_1,x_1) \implies y_2 \poker y_1
\end{align*}


The remaining objects all use the first two formulas (the one recognizing
total order violations, and the one recognizing matching violations).

\item 
For the Stack, the first four formulas are similar to the Queue, except we change
\<dequeue> to \<pop>, and \<enqueue> to \<push>. Then, in order to
recognize LIFO violations, we use a formula slightly different than the formula 
recognizing FIFO violations.  We need one more constraint ($x_1 \poker y_2$), since 
the order of operations $x_2 \poker y_2 \land y_2 \poker x_1$ does not yield a
violation of the LIFO order.
\begin{align*}
\exists x_2,x_1,y_2.
  &\ x_2 \poker x_1 \land x_1 \poker y_2 
    \land \<Matching>(y_2,x_2) \land \<push>(x_1) \land \\
  &\forall y_1.\ 
      \<Matching>(y_1,x_1) \implies y_2 \poker y_1
\end{align*}


\item 
For the Register, we use the same first three formulas (total order, matching \<read>
to \<write>, and each \<read> has a matching \<write> which precedes it).
The fourth formula recognize histories where there is a read ($y_2$) with 
no matching write ($x_2$) in between $y_2$ and the preceding write ($x_1$).
\begin{align*}
  \exists x_1,y_2.
    &\ x_1 \poker y_2 \land \<write>(x_1) \land
      \<read>(y_2) \land \neg \<Matching>(y_2,x_1) \land\\
    &\forall x_2.\ x_1 \poker x_2 \land x_2 \poker y_1 \implies 
      \neg \<Matching>(y_2,x_2)
\end{align*}


\item
The PriorityQueue uses the same first four formulas as the Queue. The fifth formulas
is changed so as not to detect FIFO violations, but priority violations. A history has 
a priority violation if two elements have
been added ($x_1,x_2$), and the element with lower priority ($x_1$) has been 
removed (by $y_1$), while $x_2$ has not yet been removed (by $y_2$).
\todo{We don't have a predicate to compare data values.}  
\begin{align*}
\exists x_1,x_2,y_1.& \<Matching>(y_1,x_1) \land x_2 \poker y_1 \land \<add>(x_2) \land\\
& \cval{x_1} < \cval{x_2} \land \forall y_2.\ y_2 \poker y_1.\ \neg \<Matching>(y_2,x_2)
\end{align*}


%\item
%For the Set, we use two formulas, one for $\tt contains => true$ violations, 
%and one for $\tt contains => false$ violations.
%
%The first one says that there is a $\tt contains => true$  ($x_c$)
%and a remove, so that there is no add in between.
%\begin{align*}
%\exists x_r,x_c.\ &
%  \<remove>(x_r) \land \<contains>(x_c) \land \rval{x_c} = \<true>
%  \land x_r \poker x_c \land\\
%    &\forall x_a.\ x_r \poker x_a \land x_a \poker x_c \implies 
%      \neg \<Matching>(x_c,x_a)
%\end{align*}
%
%The second one says that there is a $\tt contains => false$ (abbreviated $CF$)
%and an add, so that there is no remove in between.
%\begin{align*}
%\exists x_a,x_c.\ &
%  \<add>(x_a) \land \containsfalse(x_c)
%  \land x_a \poker x_c \land\\
%   & \forall x_r.\ (x_a \poker x_r \land x_r \poker x_c \land \<remove>(x_r))
%    \implies \\
%    &\qquad \neg \<Matching>(x_r,x_a)
%\end{align*}


\item
For the Set, we use the formula which detects total order violations as for 
the previous objects. We also use a formula which says that only \<remove>
and \<add> operations can be matched. 

However, as opposed to
the multiset objects (Stack, Queue), we do not 
require every \<remove> operation to match some \<add> operation, as 
a remove can succeed even though the element was already removed from 
the set. We use then use two formulas,
one for $\sf contains => true$ violations, 
and one for $\sf contains => false$ violations.

The first one says that there is a $\sf contains => true$ ($x_c$) so that all 
matching pairs of \<add>/\<remove> are either completely before or 
completely after it (so this \<contains> was supposed to return \<false>).
\begin{align*}
\exists x_c.\ &
  \<contains>(x_c) \land \rval{x_c} = \<true> \land\\
   & \forall x_a,x_r.\ \<Matching>(x_r,x_a) \implies \\
&	((x_a \poker x_c \land x_r \poker x_c)
 	\lor (x_c \poker x_a \land x_c \poker x_r))
\end{align*}

The second one says that there is a $\sf contains => false$ ($x_c$)
and a matching pair of \<add>/\<remove> ($x_a/x_r$) so that the \<add> and \<remove>
are respectively before and after $x_c$ (so this \<contains> was supposed
to return \<true>).
\begin{align*}
\exists x_a,x_c,x_r.\ &
  \<contains>(x_c) \land \rval{x_c} = \<false> \\
&\land x_a \poker x_c \land x_c \poker x_r \land \<Matching>(x_r,x_a)
\end{align*}

\item
For the Lock, just like the set, we do not require every \<unlock> to be matched
with a \<lock>, as the \<unlock> method can be called by a client even though the Lock
is already free. We then use a formula which recognizes histories where two lock 
operations follow each other:
\begin{align*} 
\exists x_1,x_2.&\ 
  x_1 \poker x_2 \land \<lock>(x_1) \land \<lock>(x_2) \land\\
  &\forall y. \neg (x_1 \poker y \land y \poker x_2)
\end{align*}

\item
Likewise, for the Semaphore, we do not require every \<release> to be matched
with an \<acquire>.
The violations of a Semaphore of capacity $\capacity$ are histories where
at some point, there are strictly more than $\capacity$ 
\<acquire>'s ($x_0,\dots,x_\capacity$) which are 
not matched by corresponding \<release>'s ($y$). The corresponding formula is 
parametrized by $\capacity$.
\begin{align*}
\exists x_0,\dots,x_\capacity.&\ 
  \bigwedge_{0 \leq i < \capacity} x_i \poker x_\capacity \land
  \bigwedge_{0 \leq i \leq \capacity} \<acquire>(x_i) \land\\
  &(\forall y.\ y \poker x_\capacity \implies 
    \bigwedge_{0 \leq i \leq \capacity} \neg \<Matching>(y,x_i))
\end{align*}


\item
The Exchanger is a special case. First of all, we drop the formula stating
that $\poker$ is a total order. Moreover, the \<exchange> label can be both
positive and negative. We use three formulas to recognize violations of the 
Exchanger. 

The first one states that there exists an operation which was 
matched twice (an operation
can exchange its value with only one operation).
\begin{align*}
\exists x,y_1,y_2.\ \<Matching>(y_1,x) \land \<Matching>(y_2,x)
\end{align*}

The second one says 
that there exists an operation which was not matched, but which returned 
something different than the expected $\noexc$
\begin{align*}
\exists x,y.&\ \rval{x} \neq \noexc \land \\
& \forall y.\ \neg \<Matching>(y,x) \land \neg \<Matching>(x,y)
\end{align*}

The last one says that there exists one operation which was matched,
but which did not return the value of the corresponding operation.
\begin{align*}
\exists x,y.\ (\<Matching>(y,x) \lor \<Matching>(x,y)) \land \rval{x} \neq
\cval{y}
\end{align*}

\end{itemize}

\end{example}
